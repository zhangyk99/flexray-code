/**
 * Copyright (c) 2026:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_TA1015_TYPES_H
#define __TSDEV_API_TA1015_TYPES_H
#include "tsdev_api_base_types.h"

// arinc429 callback event
typedef tsdev_err_t(*tsdev_arinc429_tx_cmd_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
    uint16_t rev, uint16_t fsize, const struct tsdev_arinc429_tx_cmd_req_rsp_t* data);
typedef tsdev_err_t(*tsdev_arinc429_rx_cmd_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
    uint16_t rev, uint16_t fsize, const struct tsdev_arinc429_rx_cmd_req_rsp_t* data);
typedef tsdev_err_t(*tsdev_arinc429_frm_done_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
    uint16_t rev, uint16_t fsize, const struct tsdev_arinc429_frm_done_t* data);

// 1553B callback event
typedef tsdev_err_t(*tsdev_1553B_cmd_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
    uint16_t rev, uint16_t fsize, const struct tsdev_mil1553b_cmd_req_rsp_t* data);
typedef tsdev_err_t(*tsdev_1553B_frm_done_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
    uint16_t rev, uint16_t fsize, const struct tsdev_mil1553b_frm_done_t* data);

// uart callback event
typedef tsdev_err_t(*tsdev_uart_cmd_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
    uint16_t rev, uint16_t fsize, const struct tsdev_uart_cmd_req_rsp_t* data);
typedef tsdev_err_t(*tsdev_uart_frm_done_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
    uint16_t rev, uint16_t fsize, const struct tsdev_uart_frm_done_t* data);

//--------------------------------------------------------------for 429 bus----------------------------------------------------
#define TS429_RX_LABEL_NUMBERS 256

struct tsdev_arinc429_tx_cmd_req_rsp_t {
    uint64_t timestamp; //us, hw local timestamp when this command is issued
    uint8_t version;    //cmd version  
    uint8_t cmd_typ;    //cmd for tsdev_arinc429_tx_cmd_par_t
    uint8_t cmd_mod;    //bit7: 0-req, 1-rsp; bit0: 0-ok, 1-nok;            
    uint8_t Idx_chn;    //chn num 

    uint8_t rev[4];

    union tsdev_arinc429_tx_cmd_par_t {
        uint8_t rev[256 + 8];     //

        struct tsdev_arinc429_tx_cmd_par_ctrl_t {
            uint8_t run_mode;        //start or stop the core.
        } cmd0;

        struct tsdev_arinc429_tx_cmd_par_cfg_t {
            uint8_t base_config; // 429 tx_normal reg
            // [0~1] : data rate: 00=12.5kbps, 01=50kbps, 10=100kbps
            // [2] : enable 32bit as parity 0=data 1=parity
            // [3] : parity 0=odd 1=even
            // [4] : 0: normal, 1: loopback

            uint8_t word_interval;// word interval time, resultion:10us, 0-2550us;
        } cmd1;

        struct tsdev_arinc429_tx_cmd_par_cycle_frm_t {
            uint8_t frm_cnt;
            struct tsdev_arinc429_tx_cmd_par_frm_def_t {
                uint32_t data;//Initialize data
                // [0~7]: 8bit label
                // [8~9]: 2bit SDI
                // [10~28]: 19bit data
                // [29~30]: 2bit SSM
                // [31]: 1bit parity
                uint16_t cycle; // resultion:1ms, 1-65535ms; 0 not send;
                uint16_t nums; // cycle frm send nums, 0 not send, 0xFF stands for infinite num;
            } cycle_frm[256];//msg idx, in fact is 0-254
        } cmd2;
    } pars;
};

struct tsdev_arinc429_rx_cmd_req_rsp_t {
    uint64_t timestamp; //us, hw local timestamp when this command is issued
    uint8_t version;    //cmd version  
    uint8_t cmd_typ;    //cmd, current no tsdev_arinc429_rx_cmd_par_t, always 0;
    uint8_t cmd_mod;    //bit7: 0-req, 1-rsp; bit0: 0-ok, 1-nok;            
    uint8_t Idx_chn;    //chn num 

    uint8_t rev[2];     //

    uint8_t base_config; // 429 control reg
    // [0~1] : data rate: 00=12.5kbps, 01=50kbps, 10=100kbps
    // [2] : label compare 0=disable 1=enable
    // [3] : enable 32bit as parity 0=data 1=parity
    // [4] : parity 0=odd 1=even
    // [5] : decoder 0=SDI bit compare disable 1=enable
    // [6] : SDI bit 9 if decoder is enable match SDI bit9
    // [7] : SDI bit 10 if decoder is enable match SDI bit 10

    struct tsdev_arinc429_rx_cmd_label_t {
        uint8_t num; // RX labels number
        uint8_t val[TS429_RX_LABEL_NUMBERS]; // RX lables up to 255
    } label_config;
};

struct tsdev_arinc429_frm_tx_t
{
    uint8_t version; // frm version
    uint8_t frm_typ;
    //[0-1]: 0=RX, 1=TX, 2=TxReq
    //[2]:0=correct,1=incorrect (Parity error flag)
    //[3]: tx fifo mode or not, 0: fifo mode; 1: not fifo mode;
    uint8_t Idx_chn; // physical channel index

    uint8_t msg_idx; // 0xFF means random msgs

    uint32_t data;
    // [0~7]: 8-bit label
    // [8~9]: 2-bit SDI (or reserved based on format)
    // [10~28]: 19-bit data
    // [29~30]: 2-bit SSM (Sign/Status Matrix)
    // [31]: 1-bit parity
};

struct tsdev_arinc429_frm_done_t
{
    uint64_t timestamp; //us, hw local timestamp when this command is issued
    struct tsdev_arinc429_frm_tx_t info;
};


//--------------------------------------------------------------for 1553B bus----------------------------------------------------
struct tsdev_mil1553b_cmd_req_rsp_t {
    uint64_t timestamp; //us, hw local timestamp when this command is issued
    uint8_t version;    //cmd version  
    uint8_t cmd_typ;    //cmd for tsdev_MIL_STD_1553B_tx_cmd_par_t
    uint8_t cmd_mod;    //bit7: 0-req, 1-rsp; bit0: 0-ok, 1-nok;            
    uint8_t idx_chn;    //chn num 

    uint8_t rev[4];

    union tsdev_mil1553b_cmd_par_t {
        uint8_t rev[96];

        struct tsdev_mil1553b_cmd_par_Run_ctrl_t {
            uint8_t run_mode;
            //[7]: running, start/stop the mode, 
            //[3]: baudrate: 0-1m, 1-4m
            //[2]: bus_type: 0-1553B, 1-1553A
            //[0-1]: bus_mode: 00-bc, 01-rt, 10-bm
            //stop would first stop the ip and then clear all config
            //before start, e.g. BC, the cmd_1 and N*cmd_4 would be sent to linux, and then start the ip.
        } cmd_0;

        struct tsdev_mil1553b_cmd_par_BC_Cfg_t {
            uint8_t BC_mode;
            //[0]: the core will alternate between Bus A and Bus B on message retries, BC only.
        } cmd_1;

        struct tsdev_mil1553b_cmd_par_RT_Cfg_t {
            uint8_t RT_mode;
            //[7:6]: Bus A/Bus B enable, when disabled, the bus cmds are ignored, RT only.
            //[5]: Dynamic Bus Control Acceptance, RT only.
            //[4:0]: remote terminal address, RT only.
        } cmd_2;

        struct tsdev_mil1553b_cmd_par_BM_Cfg_t {
            uint8_t BM_mode;
        } cmd_3;

        struct tsdev_mil1553b_cmd_par_BC_Msg_Cfg_t {
            uint8_t msg_idx; //for locate the msg locally, max support 8*1024=8192 entries, 
            uint8_t msg_idx_branch; //if this msg has branch, this means the branch msg idx.
            uint16_t ctrl_word;
            //[15:12]: opcode:
            //0000 End of List
            //0001 Skip, should be inserted between two msgs to keep the msg gap.
            //0010 Go To
            //0011 BIT
            //0100 Execute Block - Continue
            //0101 Execute Block - Branch
            //0110 Execute Block - Branch on Condition
            //0111 Retry on Condition
            //1000 Retry on Condition - Branch
            //1001 Retry on Condition - Branch if All Retries Fail
            //1010 Interrupt - Continue
            //1011 Call
            //1100 Return to Call
            //1101 Reserved
            //1110 Load Minor Frame Timer, should be added to the head of the minor frame to keep the frame gap.
            //1111 Return to Branch
            //[11:10]: Retry num, 00: retry num is 4, 01: retry num is 1, 10: retry num is 2, 11: retry num is 3
            //[9]: primary CHA/CHB: 1=Channel B, 0=Channel A
            //[8]: RT-RT msg
            // [7] : 1-Mask, core detects an error in the response from the RT or if there is no response after the message timeout period has expired.
            // [6] : 1-Mask, core receives a Status Word response from the RT with the Message Error bit set (bit 9 in 1553A mode).
            // [5] : 1-Mask, core receives a Status Word response from the RT with the Busy bit set (bit 16 in 1553A mode).
            // [4] : 1-Mask, core receives a Status Word response from the RT with the Terminal Flag bit set (bit 19 in 1553A mode).
            // [3] : 1-Mask, core receives a Status Word response from the RT with the Subsystem Fail bit set (bit 17 in 1553A mode).
            // [2] : 1-Mask, core receives a Status Word response from the RT with the Instrumentation bit set (bit 10 in 1553A mode).
            // [1] : 1-Mask, core receives a Status Word response from the RT with the Service Request bit set (bit 11 in 1553A mode)
            // [0] : 1-Mask, core detects Loopback fails, or RT address mismatch, or ...
            uint16_t cmd_word1; //rt_addr, tx/rx, sub_addr, data word cnt
            uint16_t cmd_word2; //RT-RT need cmd2
            uint16_t data_word[32]; //init msg data 
            uint16_t timer_val;
        } cmd_4;
        struct tsdev_mil1553b_cmd_par_RT_Msg_Cfg_t {
            uint16_t msg_ctl; //almost the same as the cmd word
            //[15:11]: Word cnt or Mode Code value
            //[10:6]: Subaddress/Mode
            //[5]: Tx/Rx
            //[4:0]: rev
            uint16_t msg_data[32]; //only for Tx msg init data
            uint16_t sts_word;
        } cmd_5;
        struct tsdev_mil1553b_cmd_par_BM_Msg_Cfg_t {
            uint32_t msg_filter; //bit mask filter for all RT addr
        } cmd_6;
    }pars;
};

struct tsdev_mil1553b_frm_tx_t {
    uint8_t version; //frm version
    uint8_t frm_mod;
    //[0:1]: 00=RX, 01=TX, 10=TxReq
    //[2]: RT-RT msg or not
    //[3]: BC-TX, RT-TX
    uint8_t frm_typ;//frm0 or frm1
    uint8_t idx_chn; // physical channel index
    uint8_t rev[4];

    union tsdev_mil1553b_frm_par_t {
        uint8_t rev[96];

        struct tsdev_mil1553b_frm_par_BC_Msg_t {
            uint8_t msg_typ;
            //[0]: sched msg or random msg.
            //[1]: for random msg, the priority: 1-high, 0-low.
            uint8_t msg_idx; //for locate the msg locally, max support 8*1024=8192 entries, for random msg, msg_idx no use.
            uint8_t msg_idx_brch;
            uint8_t rev;
            uint16_t ctrl_word;
            uint16_t cmd_word1; //rt_addr, tx/rx, sub_addr, data word cnt
            uint16_t cmd_word2; //RT-RT need cmd2
            uint16_t data_word[32];
        } frm_0;

        struct tsdev_mil1553b_frm_par_RT_Msg_t {
            uint16_t msg_ctl;//almost the same as the cmd word
            //[15:11]: word cnt or Mode Code value
            //[10:6]: Subaddress/Mode
            //[5]: Tx/Rx, const Tx
            //[4:0]: rev
            uint16_t msg_data[32];
            uint16_t sts_word;
        } frm_1;
    }pars;
};

struct tsdev_mil1553b_frm_done_t {
    uint64_t timestamp;    // us
    uint8_t version; //frm version
    uint8_t frm_mod;
    //[0:1]: 00=RX, 01=TX, 10=TxReq
    //[2:3]: 00=BC->RT, 01=RT->BC, 10=RT->RT
    uint8_t Idx_chn; // physical channel index
    uint8_t rev[5];

    uint16_t msg_info;
    //[15]: cha/chb
    //[14]: RT-RT msg:The RT-RT bit indicates whether the current message involves an RT-to-RT transfer
    //[13]: msg err, stands for all related msg err
    //[12]: subaddr or mode code not match
    //[11]: timeout err
    //[10]: overrun err, data word recv than expected
    //[9]: parity err
    //[8]: manchester decoding err
    //[7]: RT addr not match

    uint16_t cmd_word1; // include rt_addr, sub_addr, tx/rx, msg_count
    uint16_t cmd_word2; // RT to RT need Cmd2
    uint16_t msg_data[32];
    uint16_t rev1[3];
    uint16_t sts_word1;
    uint16_t sts_word2;
};



//--------------------------------------------------------------for RS485 bus----------------------------------------------------
struct tsdev_uart_cmd_req_rsp_t {
    uint64_t timestamp; //us, hw local timestamp when this command is issued
    uint8_t version;    //cmd version  
    uint8_t cmd_typ;
    //[0:1]: 00-rs232, 01-rs485, 10-rs422
    uint8_t cmd_mod;
    //[0]: 0-ok, 1-nok;     
    //[7]: 0-req, 1-rsp;        
    uint8_t Idx_chn;

    uint8_t rev0[4];

    uint8_t baud_rate;  //cur is 110~921600 enum, -10Mbps tbd.
    uint8_t data_prop;
    //[0-1]: data_bits, 00-5, 01-6, 10-7, 11-8
    //[2-3]: stop_bits, 00-1, 01-1.5, 10-2
    //[4-6]: parity, 000=none, 001=odd, 010=even, 011=mark, 100=space

    uint8_t rev1[5];
    uint8_t res_prop;
    //[0]: res_term, termination resistor, 120Ohm: 0-do not install; 1-install
    //[1]: res_bias, bias resistor, 4.7kOhm pullup and pulldown: 0-do not install; 1-install
};

struct tsdev_uart_frm_tx_t
{
    uint8_t version;     //frm version
    uint8_t frm_typ;
    //[0-1]: 00-rs232, 01-rs485, 10-rs422
    //[7]: 0=RxTxDone, 1=TxReq
    uint8_t Idx_chn; // physical channel index
    uint8_t rev[4];

    uint8_t dlc;   //1-64 bytes.
    uint8_t data[64];
};

struct tsdev_uart_frm_done_t
{
    uint64_t timestamp; //us, hw local timestamp when this command is issued
    uint8_t version;    //frm version
    uint8_t frm_typ;
    //[0-1]: 00-rs232, 01-rs485, 10-rs422
    //[7]: 0=RxTxDone, 1=TxReq
    uint8_t Idx_chn; // physical channel index
    uint8_t rev[4];

    uint8_t dlc; //1-64 bytes.
    struct _tsdev_uart_frm_done_data_t
    {
        uint8_t data;
        uint8_t info;
        //[0]: 0-Rx Done, 1-Tx Done
        //[1]: parity err
        //[2]: frame err
        //[3]: overrun err
    } data[64];
};

#endif