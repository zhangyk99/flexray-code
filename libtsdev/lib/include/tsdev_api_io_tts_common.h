/**
 * Copyright (c) 2026:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_IO_COMMON_H
#define __TSDEV_API_IO_COMMON_H

#include "tsdev_types.h"

#ifdef __cplusplus
extern "C"
{
#endif

enum tsdev_dev_io_tts_cmd_enum {
    tsdev_dev_tts_init_setup = 0,
    tsdev_dev_tts_voltage_lvl = 1,
    tsdev_dev_tts_voltage_cmp = 2,
    tsdev_dev_tts_aiao_voltage_out_lvl = 3,
    tsdev_dev_tts_aiao_voltage_in_lvl = 4,
    tsdev_dev_tts_set_mode = 5,
    tsdev_dev_tts_set_status = 6,
    tsdev_dev_tts_pwm_write = 7,
    tsdev_dev_tts_pwm_read = 8,
    tsdev_dev_tts_bit_write = 9,
    tsdev_dev_tts_bit_read = 10,
    tsdev_dev_tts_aiao_write = 11,
    tsdev_dev_tts_aiao_read = 12,
    tsdev_dev_tts_ai_ch_mode_set = 13,
    tsdev_dev_tts_ao_ch_mode_set = 14,
};

enum tsdev_dev_io_tts_daq_enum {
    tsdev_dev_tts_status_report = 0
    , tsdev_dev_tts_pwm_report = 1
    , tsdev_dev_tts_bit_stream_report = 2
    , tsdev_dev_tts_ai_report = 3
    , tsdev_dev_tts_ao_report = 4
};


//cmd_resp commmend
//dido voltage_lvl
typedef struct tsdev_dev_voltage_lvl_cmd1_resp1 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enum
    uint8_t group_idx;      // Group index (4 channels per group)
    uint8_t voltage_lvl;    // 0: BAT, 1: EXT
    uint8_t rev[5];
}tts_cmd1_resp1;
// Set sampling comparator threshold voltage
typedef struct tsdev_dev_voltage_cmp_cmd2_resp2 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enum
    uint8_t group_idx;      // Group index (8 channels per group)
    uint16_t voltage;       // Threshold voltage
    uint8_t rev[4];
}tts_cmd2_resp2;

// aiao voltage_lvl channel
typedef struct tsdev_dev_aiao_voltage_lvl_cmd3_resp3 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enum
    uint8_t aiao_idx;       // Channel index
#define CHANNLE_OK          (0)
#define CHANNLE_CONN_COM    (1 << 0)
#define CHANNLE_CONN_GND    (1 << 1)
#define CHANNLE_CONN_BAT    (1 << 2)
#define CHANNLE_DISABLE    (1 << 3)
    uint8_t voltage_lvl;    // Routing: 0=disconnected; bit0=COM; bit1=GND; bit2=BAT; bit3=DISABLE
    uint8_t rev[5];
}tts_cmd3_resp3;

//dido mode
typedef struct tsdev_dev_tts_dido_cmd4_resp4 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enum
    uint8_t dido_idx;       // Channel index
    uint8_t dido_mode0;     //bit0-1: io type: 0: io; 1: pwm  2 :bit
    uint8_t dido_mode1;     //bit0-1: 0: push-pull; 1: pull(p-mos) only; 2: push(n-mos) only /// ? out high/low level
    uint16_t report_cycle_ms;//tsdev_dev_dido_pwm_report report cycle
    uint8_t rev[2];
}tts_cmd4_resp4;

//dio write read
typedef struct tsdev_dev_tts_dido_cmd5_resp5 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enum
    uint8_t dido_idx;       // Channel index
    uint8_t io_status;      // Output value: 0=low, 1=high
    uint8_t rev[5];
}tts_cmd5_resp5;
//pwm write read
typedef struct tsdev_dev_tts_dido_cmd6_resp6 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enu
    uint8_t dido_idx;       // Channel index
    uint16_t duty;          //uint is 0.1%
    uint32_t freq;          //unit is 0.01hz
    uint32_t pwm_sample_us; // Sampling time (us)
    uint32_t report_cycle_ms; // Report cycle (ms)
}tts_cmd6_resp6;

//bit stream write
typedef struct tsdev_dev_tts_dido_cmd7_resp7 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enum
    uint8_t dido_idx;       // Channel index, 1..16
    uint8_t delay;          // Startup delay, 0..40 (0.1 s)
    uint8_t rev;
    uint16_t loopcnt;       // Loop count, 0..65535, 0=infinite
    uint16_t pause;         // Loop interval, 0..42940 (0.1 s)
    uint16_t cnt;           // Number of bits to send, 2..4096
    uint16_t sp;            // Start position, 0..4095
    int32_t bittime;        // Bit width (0.1 us): +/-25..+/-650000; negative = reverse output order.
                            // Example: sp=2 outputs bit2, bit1, bit0.
    uint8_t bit[512];       // Payload (4096 bits)
}tts_cmd7_resp7;
//bit stream read
typedef struct tsdev_dev_tts_dido_cmd8_resp8 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enum
    uint8_t dido_idx;       // Channel index
    uint32_t bit_data;      // Captured bit value (20 bits)
    uint8_t rev[2];
}tts_cmd8_resp8;
//aiao write read 
typedef struct tsdev_dev_tts_aiao_cmd9_resp9 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enu
    uint8_t aiao_idx;
    uint16_t voltage;       // Output voltage value, 0..10 V, unit: mV
    uint8_t rev[4];
}tts_cmd9_resp9;

//aiao channle mode
typedef struct tsdev_dev_tts_aiao_cmd10_resp10 {
    uint8_t cmd;            //tsdev_dev_io_cmd_enu
    uint8_t aiao_idx;
    uint8_t mode;       // 0=disconnected, 1=latched
    uint8_t rev[5];
}tts_cmd10_resp10;



#ifdef __cplusplus
}
#endif

#endif
