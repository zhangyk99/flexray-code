/*
Copyright (c) 2024:Shanghai TOSUN Technology Ltd.

The software mentioned in this copyright statement includes the automatic code generator function module of TSMaster software and the embedded code it generates. Among them, the copyright of the automatic code generation function module of TSMaster software is owned by Shanghai TOSUN Technology Ltd..It is protected by the Copyright Law of the People's Republic of China, the Regulations on the Protection of Computer Software, the Intellectual Property Protection Law, the Patent Law of the People's Republic of China and relevant international copyright treaties, laws, regulations, and other intellectual property laws and treaties.

The embedded code generated by the automatic code generation function of the TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN Technology Ltd. or the original copyright owner of the embedded code, and is only for personal learning and use. Shanghai TOSUN Technology Ltd. does not provide any kind of warranty, whether express or implied. All risks are borne by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint responsibility.

The semiconductor manufacturer's LOGO and product model displayed in the TSMaster are only for the convenience of user selection and useage,its copyright and ownership remain with the respective copyright owners,Shanghai TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for this, and does not assume joint and several liability for any possible infringement.

Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the software mentioned in this copyright statement without notifying users, and reserves the right to modify this license agreement.
*/
#include "tsdev_usr_module_private.h"
#include "tsdev_types.h"
/*
static int strcmp_simple(const char* s1, const char* s2) {
	while (*s1 != '\0' && *s1 == *s2) {
		s1++;
		s2++;
	}
	return (*(const unsigned char*)s1) - (*(const unsigned char*)s2);
}*/
#include <stddef.h>
#include <stdint.h>
#include <string.h>
//use strcmp_simple is something wrong in rt version
#define strcmp_port strcmp

static tsdev_err_t tsdev_api_log_out_s(tsdev_handle_t handle, tsdev_log_lvl_t lvl, const char* msg)
{
	return tsdev_err_fun_not_support;
}
static void* tsdev_api_malloc_s(size_t size)
{
	return NULL;
}
static void tsdev_api_free_s(void* ptr)
{
}
static tsdev_err_t tsdev_api_get_device_cnt_s(tsdev_handle_t handle, uint16_t* cnt)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_get_device_handle_s(tsdev_handle_t handle, uint16_t idx, tsdev_handle_t* dev_handle_p, struct tsdev_info_t* info_p)
{
	return tsdev_err_fun_not_support;
}
//-----------------for host------------------------------------
void* host_data_ptr = NULL;
size_t host_data_size = 0;
tsdev_err_t(*tsdev_api_log_out)(tsdev_handle_t handle, tsdev_log_lvl_t lvl, const char* msg) = tsdev_api_log_out_s;
void* (*tsdev_api_malloc)(size_t size) = tsdev_api_malloc_s;
void  (*tsdev_api_free)(void* ptr) = tsdev_api_free_s;
tsdev_err_t(*tsdev_api_get_device_cnt)(tsdev_handle_t handle, uint16_t* cnt) = tsdev_api_get_device_cnt_s;
tsdev_err_t(*tsdev_api_get_device_handle)(tsdev_handle_t handle, uint16_t idx, tsdev_handle_t* dev_handle_p, struct tsdev_info_t* info_p) = tsdev_api_get_device_handle_s;



static tsdev_err_t tsdev_api_can_configure_regs_async_s(tsdev_handle_t dev_handle,
	const struct tsdev_TPC_FDHardwareConf* conf)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_can_transmit_async_s(tsdev_handle_t dev_handle,
	const struct tsdev_canfd_tx_t* can)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_can_frame_receive_s(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	tsdev_can_frame_event_t event)
{
	return tsdev_err_fun_not_support;
}
//-------------------tsdev_api_can.h-----------------
tsdev_err_t(*tsdev_api_can_configure_regs_async)(tsdev_handle_t dev_handle,
	const struct tsdev_TPC_FDHardwareConf* conf) = tsdev_api_can_configure_regs_async_s;
tsdev_err_t(*tsdev_api_can_transmit_async)(tsdev_handle_t dev_handle,
	const struct tsdev_canfd_tx_t* can) = tsdev_api_can_transmit_async_s;
tsdev_err_t(*tsdev_api_can_frame_receive)(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	tsdev_can_frame_event_t event) = tsdev_api_can_frame_receive_s;



static tsdev_err_t tsdev_api_eth_tx_cmd_async_s(tsdev_handle_t handle,
	const struct tsdev_PC_ETH_CMD_REQ* ACmdReq)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_eth_transmit_async_s(tsdev_handle_t handle,
	const struct tsdev_ETH_Header* AEthernetHeader)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_eth_fifo_receive_msgs_s(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	tsdev_api_eth_frame_event_t frame_handle)
{
	return tsdev_err_fun_not_support;
}
//-------------------tsdev_api_eth.h-----------------
tsdev_err_t(*tsdev_api_eth_tx_cmd_async)(tsdev_handle_t handle,
	const struct tsdev_PC_ETH_CMD_REQ* ACmdReq) = tsdev_api_eth_tx_cmd_async_s;
tsdev_err_t(*tsdev_api_eth_transmit_async)(tsdev_handle_t handle,
	const struct tsdev_ETH_Header* AEthernetHeader) = tsdev_api_eth_transmit_async_s;
tsdev_err_t(*tsdev_api_eth_fifo_receive_msgs)(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	tsdev_api_eth_frame_event_t frame_handle) = tsdev_api_eth_fifo_receive_msgs_s;

static tsdev_err_t tsdev_api_flexray_set_controller_frametrigger_s(tsdev_handle_t handle, const struct tsdev_TPC_FlexrayConfig* config)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_flexray_cmdreq_s(tsdev_handle_t handle, const struct tsdev_TPC_FlexrayCmdReq* req)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_flexray_start_net_s(tsdev_handle_t handle, int32_t node_idx)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_flexray_stop_net_s(tsdev_handle_t handle, int32_t node_idx)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_flexray_wakeup_pattern_s(tsdev_handle_t handle, int32_t node_idx)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_flexray_transmit_async_s(tsdev_handle_t handle, const struct tsdev_flexray_frame* AData)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_flexray_receive_s(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	tsdev_flexray_frame_event_t event)
{
	return tsdev_err_fun_not_support;
}
//-------------------tsdev_api_flexray.h-----------------
tsdev_err_t(*tsdev_api_flexray_set_controller_frametrigger)(tsdev_handle_t handle, const struct tsdev_TPC_FlexrayConfig* config) = tsdev_api_flexray_set_controller_frametrigger_s;
tsdev_err_t(*tsdev_api_flexray_cmdreq)(tsdev_handle_t handle, const struct tsdev_TPC_FlexrayCmdReq* req) = tsdev_api_flexray_cmdreq_s;
tsdev_err_t(*tsdev_api_flexray_start_net)(tsdev_handle_t handle, int32_t node_idx) = tsdev_api_flexray_start_net_s;
tsdev_err_t(*tsdev_api_flexray_stop_net)(tsdev_handle_t handle, int32_t node_idx) = tsdev_api_flexray_stop_net_s;
tsdev_err_t(*tsdev_api_flexray_wakeup_pattern)(tsdev_handle_t handle, int32_t node_idx) = tsdev_api_flexray_wakeup_pattern_s;
tsdev_err_t(*tsdev_api_flexray_transmit_async)(tsdev_handle_t handle, const struct tsdev_flexray_frame* AData) = tsdev_api_flexray_transmit_async_s;
tsdev_err_t(*tsdev_api_flexray_receive)(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	tsdev_flexray_frame_event_t event) = tsdev_api_flexray_receive_s;

static tsdev_err_t tsdev_api_io_cmd_async_s(tsdev_handle_t handle,
	const union tsdev_dev_io_cmd_resp* cmd)
{
	return tsdev_err_fun_not_support;
}
//-------------------tsdev_api_io.h-----------------
tsdev_err_t(*tsdev_api_io_cmd_async)(tsdev_handle_t handle,
	const union tsdev_dev_io_cmd_resp* cmd) = tsdev_api_io_cmd_async_s;



static tsdev_err_t tsdev_api_lin_config_s(tsdev_handle_t handle, struct tsdev_lin_config_t* cmd)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_lin_transmit_async_s(tsdev_handle_t handle, const struct tsdev_LIN_frame* lin)
{
	return tsdev_err_fun_not_support;
}
static tsdev_err_t tsdev_api_lin_fifo_receive_msgs_s(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	const tsdev_lin_frame_event_t event)
{
	return tsdev_err_fun_not_support;
}
//-------------------tsdev_api_lin.h-----------------
tsdev_err_t(*tsdev_api_lin_config)(tsdev_handle_t handle, struct tsdev_lin_config_t* cmd) = tsdev_api_lin_config_s;
tsdev_err_t(*tsdev_api_lin_transmit_async)(tsdev_handle_t handle, const struct tsdev_LIN_frame* lin) = tsdev_api_lin_transmit_async_s;
tsdev_err_t(*tsdev_api_lin_fifo_receive_msgs)(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	const tsdev_lin_frame_event_t event) = tsdev_api_lin_fifo_receive_msgs_s;

static tsdev_err_t tsdev_api_sim_sig_get_cnt_s(tsdev_handle_t handle, uint8_t core_idx, uint32_t* cnt)
{
	(void)handle;
	(void)core_idx;
	if (cnt != NULL)
	{
		*cnt = 0U;
	}
	return tsdev_err_fun_not_support;
}
tsdev_err_t(*tsdev_api_sim_sig_get_cnt)(tsdev_handle_t handle, uint8_t core_idx, uint32_t* cnt) = tsdev_api_sim_sig_get_cnt_s;

static tsdev_err_t tsdev_api_sim_sig_get_defs_s(tsdev_handle_t handle,
	uint8_t core_idx,
	uint32_t sig_start_idx,
	uint32_t read_cnt,
	struct tsdev_cal_sig_def_t* sig_defs)
{
	(void)handle;
	(void)core_idx;
	(void)sig_start_idx;
	(void)read_cnt;
	if (sig_defs != NULL)
	{
		memset(sig_defs, 0, sizeof(*sig_defs));
	}
	return tsdev_err_fun_not_support;
}
tsdev_err_t(*tsdev_api_sim_sig_get_defs)(tsdev_handle_t handle,
	uint8_t core_idx,
	uint32_t sig_start_idx,
	uint32_t read_cnt,
	struct tsdev_cal_sig_def_t* sig_defs) = tsdev_api_sim_sig_get_defs_s;

static tsdev_err_t tsdev_api_sim_core_current_s(tsdev_handle_t handle, uint8_t* core_idx)
{
	(void)handle;
	if (core_idx != NULL)
	{
		*core_idx = 0U;
	}
	return tsdev_err_fun_not_support;
}
tsdev_err_t(*tsdev_api_sim_core_current)(tsdev_handle_t handle, uint8_t* core_idx) = tsdev_api_sim_core_current_s;

static tsdev_err_t tsdev_api_sim_dp_group_fifo_receive_msgs_s(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	tsdev_api_dp_group_event_t event_handle)
{
	(void)handle;
	(void)usr_arg;
	(void)max_rx_cnt;
	(void)event_handle;
	return tsdev_err_fun_not_support;
}
tsdev_err_t(*tsdev_api_sim_dp_group_fifo_receive_msgs)(tsdev_handle_t handle,
	void* usr_arg,
	uint32_t max_rx_cnt,
	tsdev_api_dp_group_event_t event_handle) = tsdev_api_sim_dp_group_fifo_receive_msgs_s;

// Map callback entry names to the corresponding field offsets in struct sim_callbacks.
typedef struct {
	const char* name;
	size_t offset;
} SimCallbackMeta;

static const SimCallbackMeta sim_callback_meta[] = {
	{ "tsdev_start", offsetof(struct sim_callbacks, tsdev_start) },
	{ "tsdev_cycle_entry_pre", offsetof(struct sim_callbacks, tsdev_cycle_entry_pre) },
	{ "tsdev_cycle_entry", offsetof(struct sim_callbacks, tsdev_cycle_entry) },
	{ "tsdev_cycle_entry_after", offsetof(struct sim_callbacks, tsdev_cycle_entry_after) },
	{ "tsdev_stop", offsetof(struct sim_callbacks, tsdev_stop) },
	{ "tsdev_can_cmd_event", offsetof(struct sim_callbacks, tsdev_can_cmd_event) },
	{ "tsdev_can_frame_event", offsetof(struct sim_callbacks, tsdev_can_frame_event) },
	{ "tsdev_api_eth_cmd_event", offsetof(struct sim_callbacks, tsdev_api_eth_cmd_event) },
	{ "tsdev_api_eth_frame_event", offsetof(struct sim_callbacks, tsdev_api_eth_frame_event) },
	{ "tsdev_flexray_cmd_resp_event", offsetof(struct sim_callbacks, tsdev_flexray_cmd_resp_event) },
	{ "tsdev_flexray_frame_event", offsetof(struct sim_callbacks, tsdev_flexray_frame_event) },
	{ "tsdev_io_cmd_event", offsetof(struct sim_callbacks, tsdev_io_cmd_event) },
	{ "tsdev_io_daq_event", offsetof(struct sim_callbacks, tsdev_io_daq_event) },
	{ "tsdev_lin_cmd_event", offsetof(struct sim_callbacks, tsdev_lin_cmd_event) },
	{ "tsdev_lin_frame_event", offsetof(struct sim_callbacks, tsdev_lin_frame_event) }
};
typedef struct {
	const char* name;
	void** func_ptr;
} FuncMapping;

#define GEN_FUNC_MAP(name_literal, host_sym) { name_literal, (void**)&(host_sym) },
static const FuncMapping func_map[] = {
	TSDEV_USR_MODULE_FUNC_LIST(GEN_FUNC_MAP)
};
#undef GEN_FUNC_MAP

static uint16_t tsdev_usr_callback_capacity(void)
{
	return (uint16_t)(sizeof(sim_callback_meta) / sizeof(sim_callback_meta[0]));
}

static void* tsdev_usr_callback_read(const struct sim_callbacks* callbacks, size_t offset)
{
	void* result = NULL;
	const uint8_t* base;
	if (callbacks == NULL || offset >= sizeof(*callbacks))
	{
		return NULL;
	}
	base = (const uint8_t*)callbacks;
	memcpy(&result, base + offset, sizeof(result));
	return result;
}

static void* tsdev_usr_callback_resolve(const struct sim_callbacks* callbacks, const char* name, size_t offset)
{
	if (callbacks == NULL)
	{
		return NULL;
	}
	if (offset < sizeof(*callbacks))
	{
		return tsdev_usr_callback_read(callbacks, offset);
	}
	if (name == NULL)
	{
		return NULL;
	}
	for (uint16_t idx = 0; idx < tsdev_usr_callback_capacity(); ++idx)
	{
		if (strcmp_port(name, sim_callback_meta[idx].name) == 0)
		{
			return tsdev_usr_callback_read(callbacks, sim_callback_meta[idx].offset);
		}
	}
	return NULL;
}

static uint16_t tsdev_usr_callback_count(const struct sim_callbacks* callbacks)
{
	uint16_t count = 0U;
	if (callbacks == NULL)
	{
		return 0U;
	}
	for (uint16_t idx = 0; idx < tsdev_usr_callback_capacity(); ++idx)
	{
		if (tsdev_usr_callback_read(callbacks, sim_callback_meta[idx].offset) != NULL)
		{
			++count;
		}
	}
	return count;
}


TSDEV_USR_API int8_t tsdev_api_version(uint8_t* main_v, uint8_t* mid_v, uint8_t* sub_v, const char** gen_time)
{
	if (main_v != NULL)
	{
		*main_v = FILE_VERSION_MAIN;
	}
	if (mid_v != NULL)
	{
		*mid_v = FILE_VERSION_MID;
	}
	if (sub_v != NULL)
	{
		*sub_v = FILE_VERSION_SUB;
	}
	if (gen_time != NULL)
	{
		*gen_time = __DATE__ " " __TIME__;
	}
	return tsdev_err_ok;
}

#define TSDEV_USR_MODULE_MAX_CORES 64

struct tsdev_usr_core_handle {
	uint8_t used;
	uint8_t index;
	const struct tsdev_usr_module_core_desc* desc;
};

static struct tsdev_usr_core_handle g_tsdev_usr_core_handles[TSDEV_USR_MODULE_MAX_CORES];

static void tsdev_usr_reset_core_handles(void)
{
	for (uint8_t handle_idx = 0; handle_idx < TSDEV_USR_MODULE_MAX_CORES; ++handle_idx)
	{
		g_tsdev_usr_core_handles[handle_idx].used = 0U;
		g_tsdev_usr_core_handles[handle_idx].index = 0U;
		g_tsdev_usr_core_handles[handle_idx].desc = NULL;
	}
}

static const struct tsdev_usr_module_core_desc* tsdev_usr_get_core_desc(const struct tsdev_usr_module_config* cfg, uint8_t core_idx)
{
	if (cfg == NULL || cfg->cores == NULL)
	{
		return NULL;
	}
	if (core_idx >= cfg->core_cnt)
	{
		return NULL;
	}
	return &cfg->cores[core_idx];
}

static int8_t tsdev_usr_check_config(const struct tsdev_usr_module_config* cfg)
{
	if (cfg == NULL)
	{
		return -1;
	}
	if (cfg->core_cnt == 0U)
	{
		return 0;
	}
	if (cfg->cores == NULL)
	{
		return -2;
	}
	for (uint8_t core_idx = 0; core_idx < cfg->core_cnt; ++core_idx)
	{
		const struct tsdev_usr_module_core_desc* desc = &cfg->cores[core_idx];
		if (desc == NULL)
		{
			return -3;
		}
		uint16_t available_cnt = tsdev_usr_callback_count(&desc->callbacks);
		if (available_cnt > tsdev_usr_callback_capacity())
		{
			return -4;
		}
		if (desc->sig_cnt > 0U && desc->sig_defs == NULL)
		{
			return -5;
		}
	}
	return 0;
}

static struct tsdev_usr_core_handle* tsdev_usr_find_handle(uint8_t core_idx)
{
	for (uint8_t i = 0; i < TSDEV_USR_MODULE_MAX_CORES; ++i)
	{
		if (g_tsdev_usr_core_handles[i].used != 0U && g_tsdev_usr_core_handles[i].index == core_idx)
		{
			return &g_tsdev_usr_core_handles[i];
		}
	}
	return NULL;
}

static struct tsdev_usr_core_handle* tsdev_usr_alloc_handle(void)
{
	for (uint8_t i = 0; i < TSDEV_USR_MODULE_MAX_CORES; ++i)
	{
		if (g_tsdev_usr_core_handles[i].used == 0U)
		{
			g_tsdev_usr_core_handles[i].used = 1U;
			g_tsdev_usr_core_handles[i].index = 0U;
			g_tsdev_usr_core_handles[i].desc = NULL;
			return &g_tsdev_usr_core_handles[i];
		}
	}
	return NULL;
}

TSDEV_USR_API int8_t tsdev_usr_module_init(void** module_ctx)
{
	if (module_ctx == NULL)
	{
		return -1;
	}
	if (tsdev_usr_check_config(&tsdev_usr_module_config) != 0)
	{
		return -2;
	}
	*module_ctx = (void*)&tsdev_usr_module_config;
	tsdev_usr_reset_core_handles();
	return 0;
}

TSDEV_USR_API void tsdev_usr_module_uninit(void* module_ctx)
{
	(void)module_ctx;
	tsdev_usr_reset_core_handles();
}

TSDEV_USR_API int8_t tsdev_usr_module_get_core_cnt(void* module_ctx, uint8_t* cnt_p)
{
	const struct tsdev_usr_module_config* cfg = (const struct tsdev_usr_module_config*)module_ctx;
	if (cfg == NULL || cnt_p == NULL)
	{
		return -1;
	}
	*cnt_p = cfg->core_cnt;
	return 0;
}

TSDEV_USR_API int8_t tsdev_usr_module_create_core(void* module_ctx, uint8_t core_idx, tsdev_usr_core_handle_t* core_handle)
{
	const struct tsdev_usr_module_config* cfg = (const struct tsdev_usr_module_config*)module_ctx;
	const struct tsdev_usr_module_core_desc* desc;
	struct tsdev_usr_core_handle* handle;
	if (core_handle == NULL)
	{
		return -1;
	}
	desc = tsdev_usr_get_core_desc(cfg, core_idx);
	if (desc == NULL)
	{
		return -2;
	}
	handle = tsdev_usr_find_handle(core_idx);
	if (handle == NULL)
	{
		handle = tsdev_usr_alloc_handle();
		if (handle == NULL)
		{
			return -3;
		}
		handle->index = core_idx;
	}
	handle->desc = desc;
	*core_handle = handle;
	return 0;
}

TSDEV_USR_API void tsdev_usr_module_destroy_core(void* module_ctx, tsdev_usr_core_handle_t core_handle)
{
	uint8_t i;
	(void)module_ctx;
	if (core_handle == NULL)
	{
		return;
	}
	for (i = 0; i < TSDEV_USR_MODULE_MAX_CORES; ++i)
	{
		if (&g_tsdev_usr_core_handles[i] == core_handle)
		{
			g_tsdev_usr_core_handles[i].used = 0U;
			g_tsdev_usr_core_handles[i].index = 0U;
			g_tsdev_usr_core_handles[i].desc = NULL;
			break;
		}
	}
}

TSDEV_USR_API int8_t tsdev_usr_module_update_method(void* module_ctx, tsdev_usr_core_handle_t core_handle, void* _host_data_ptr, size_t _host_data_size, uint16_t method_cnt, const struct tsdev_usr_module_fun* methods)
{
	uint16_t i;
	size_t j;
	(void)module_ctx;
	(void)core_handle;
	if (methods == NULL && method_cnt > 0U)
	{
		return -1;
	}
	host_data_ptr = _host_data_ptr;
	host_data_size = _host_data_size;
	for (i = 0; i < method_cnt; ++i)
	{
		for (j = 0; j < sizeof(func_map) / sizeof(func_map[0]); ++j)
		{
			if (strcmp_port(methods[i].fun_name, func_map[j].name) == 0)
			{
				*(func_map[j].func_ptr) = methods[i].fun_ptr;
				break;
			}
		}
	}
	return 0;
}

TSDEV_USR_API int8_t tsdev_usr_module_get_core_callback(void* module_ctx, tsdev_usr_core_handle_t core_handle, uint8_t task_idx, const char** name_pp, uint16_t* sch_prescaler, uint16_t exp_callback_cnt, struct tsdev_usr_module_fun* exp_callbacks_p)
{
	uint16_t i;
	(void)module_ctx;
	(void)task_idx;
	if (core_handle == NULL || core_handle->desc == NULL)
	{
		return -1;
	}
	if (name_pp != NULL)
	{
		*name_pp = core_handle->desc->name;
	}
	if (sch_prescaler != NULL)
	{
		*sch_prescaler = core_handle->desc->sch_prescaler;
	}
	if (exp_callback_cnt > 0U && exp_callbacks_p != NULL)
	{
		const struct sim_callbacks* callbacks = &core_handle->desc->callbacks;
		for (i = 0; i < exp_callback_cnt; ++i)
		{
			exp_callbacks_p[i].fun_ptr = tsdev_usr_callback_resolve(callbacks, exp_callbacks_p[i].fun_name, exp_callbacks_p[i].offset);
		}
	}
	return 0;
}

TSDEV_USR_API int8_t tsdev_usr_module_get_sig_cnt(void* module_ctx, tsdev_usr_core_handle_t core_handle, uint32_t* cnt_p)
{
	(void)module_ctx;
	if (core_handle == NULL || core_handle->desc == NULL || cnt_p == NULL)
	{
		return -1;
	}
	*cnt_p = core_handle->desc->sig_cnt;
	return 0;
}

TSDEV_USR_API int8_t tsdev_usr_module_get_sig_defs_ptr(void* module_ctx, tsdev_usr_core_handle_t core_handle, struct tsdev_cal_sig_def_t** sig_defs)
{
	(void)module_ctx;
	if (core_handle == NULL || core_handle->desc == NULL || sig_defs == NULL)
	{
		return -1;
	}
	*sig_defs = core_handle->desc->sig_defs;
	return 0;
}
