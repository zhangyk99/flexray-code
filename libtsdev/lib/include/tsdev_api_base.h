/**
 * Copyright (c) 2026:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_BASE_H
#define __TSDEV_API_BASE_H

#include "tsdev_types.h"


#ifdef __cplusplus
extern "C"
{
#endif
#ifndef LIBTSDEVBASERT_EXPORTS
	//api for host only
	typedef void(*tsdev_scan_callback_t)(tsdev_handle_t handle, void* usr_arg, uint16_t count, tsdev_err_t err);
	typedef void(*tsdev_open_callback_t)(tsdev_handle_t handle, void* usr_arg, tsdev_err_t err);
	/**
	 * @brief scanning online TOSUN's device.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[out] count the number of scanned TOSUN's device.
	 * @param[in] timeout_ms timeout in millisecond.
	 * @param[in] when need_force_scan==1, means will force scan device infos once .Otherwise when need_force_scan==0, will return last scanned device infos.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API tsdev_api_scan(tsdev_handle_t handle, uint16_t* count,
		uint32_t timeout_ms, uint8_t need_force_scan);
	/**
	 * @brief scanning online TOSUN's device async.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] usr_callback scanning result callback.
	 * handle - pointer to tsdev api handle.
	 * usr_arg - pointer to user defined arg.
	 * count - the number of scanned TOSUN's device.
	 * tsdev_err_t - error code.
	 * @param[in] timeout_ms timeout in millisecond.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API tsdev_api_scan_async(tsdev_handle_t handle, void* usr_arg,
		tsdev_scan_callback_t usr_callback,
		uint32_t timeout_ms);
	/**
	 * @brief get device's info by handle.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] index index of selected device.
	 * @param[out] info info of selected device.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API tsdev_api_get_info(tsdev_handle_t handle, uint16_t index,
		struct tsdev_info_t* info);
	/**
	 * @brief set target device by uid.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] uid uid of device.
	 * @return if 0, ok, else nok.
	 * @note: only used to reset tartge device ip when open is not avaliable
	 */
	TSDEV_API tsdev_api_set_target(tsdev_handle_t handle, const uint8_t* uid);
	/**
	 * @brief open device by handle sync.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] uid uid of device.
	 * @param[in] timeout_ms timeout in millisecond.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API tsdev_api_open(tsdev_handle_t handle, const uint8_t* uid, const uint8_t* random_info, uint32_t timeout_ms);
	/**
	 * @brief open device by handle async.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] uid uid of device.
	 * @param[in] usr_callback scanning result callback.
	 * handle - pointer to tsdev api handle.
	 * usr_arg - pointer to user defined arg.
	 * tsdev_err_t - error code.
	 * @param[in] timeout_ms timeout in millisecond.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API tsdev_api_open_async(tsdev_handle_t handle, const uint8_t* uid, const uint8_t* random_info, void* usr_arg,
		tsdev_open_callback_t open_callback,
		uint32_t timeout_ms);
	/**
	 * @brief close device by handle.
	 * @param[in] handle pointer to tsdev api handle.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API tsdev_api_close(tsdev_handle_t handle);


	TSDEV_API tsdev_api_read_framework_info(tsdev_handle_t handle, struct framework_packet_r_t* header_p, uint32_t timeout);
	TSDEV_API tsdev_api_write_settings(tsdev_handle_t handle, const struct tsdev_device_settings_t* settings, uint32_t timeout);
	TSDEV_API tsdev_api_read_settings(tsdev_handle_t handle, struct tsdev_device_settings_t* settings, uint32_t timeout);


	/**
	 * @brief write eth config.
	 * @param[in] handle pointer to tsdev handle.
	 * @param[in] cfg pointer to eth config.
	 * @param[in] timeout timeout in ms.
	 * @return refer to tsdev_err_t.
	 */
	TSDEV_API tsdev_api_write_eth_config(tsdev_handle_t handle, const struct tsdev_eth_config_t* cfg,
		uint32_t timeout);
	/**
	 * @brief read eth config from local library cache.
	 * @param[in] handle pointer to tsdev handle.
	 * @param[out] cfg address of pointer to eth config.
	 * @param[in] timeout timeout in ms.
	 * @return refer to tsdev_err_t.
	 */
	TSDEV_API tsdev_api_read_eth_config(tsdev_handle_t handle, struct tsdev_eth_config_t* cfg,
		uint32_t timeout);

	/**
	 * @brief tsmessage memory allocation.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] size buffer length of tsmessage.
	 * @param[out] msg pointer to tsmessage.
	 * @param[out] buffer pointer to data buffer.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API  tsdev_api_mem_alloc(tsdev_handle_t handle, uint16_t size,
		tsdev_tsmsg_t* msg,
		void** header,
		uint8_t** buffer);
	TSDEV_API  tsdev_api_mem_alloc_type(tsdev_handle_t handle, uint16_t size,
		uint8_t type,
		tsdev_tsmsg_t* msg,
		void** header,
		uint8_t** buffer, int16_t target_link);
	TSDEV_API  tsdev_api_mem_alloc_fdid_pc(tsdev_handle_t handle, uint16_t size,
		uint16_t fdid, tsdev_tsmsg_t* msg,
		void** header,
		uint8_t** buffer, int16_t target_link);
	TSDEV_API  tsdev_api_mem_alloc_fdid_hw(tsdev_handle_t handle, uint16_t size,
		uint16_t fdid, tsdev_tsmsg_t* msg,
		void** header,
		uint8_t** buffer, int16_t target_link);

	/**
	 * @brief set memory free handle.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] msg pointer to tsmessage.
	 * @param[in] free_handle memory free callback.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API  tsdev_api_mem_set_free_handle(
		tsdev_tsmsg_t msg, void* usr_arg,
		uint8_t(*free_handle)(void* usr_arg,
			tsdev_tsmsg_t msg, int16_t result,
			uint8_t or_result, const uint8_t* const_header_p,
			uint8_t* data_ptr));
	/**
	 * @brief get buffer's pointer of tsmsg.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] msg pointer to tsmessage.
	 * @param[out] buffer pointer to data buffer.
	 * @param[out] len pointer to data buffer length.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API  tsdev_api_mem_get_buffer_ptr(tsdev_tsmsg_t msg,
		void** header,
		uint8_t** buffer, uint16_t* len);
	/**
	 * @brief  set memory free result.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] msg pointer to tsmessage.
	 * @param[in] or_result free result.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API  tsdev_api_mem_set_free_or_result(tsdev_tsmsg_t msg,
		uint8_t or_result);


	TSDEV_API  tsdev_api_mem_add_ref(tsdev_tsmsg_t msg);
	/**
	 * @brief  memory free.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] msg pointer to tsmessage.
	 * @param[in] result free result.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API  tsdev_api_mem_free(tsdev_tsmsg_t msg,
		int16_t result);

	/**
	 * @brief transmit tsmsg async.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] msg pointer to tsmessage.
	 * @return if 0, ok, else nok.
	 * @note
	TSDEV_API  tsdev_api_tsmsg_transmit(tsdev_handle_t handle
		, tsdev_tsmsg_t msg
		, int16_t target_link);
	 */


	/**
	 * @brief register global callback function for tsmsg rx.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] usr_arg pointer to user defined arg.
	 * @param[in] cb pointer to callback function.
	 * @return if 0, ok, else nok.
	 * @note
	TSDEV_API
		tsdev_api_reg_tsmsg_receive_callback(tsdev_handle_t handle, void* usr_arg,
			tsdev_tsmsg_receive_callback_t cb);
	 */
	/**
	 * @brief unregister global callback function for tsmsg rx.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] usr_arg pointer to user defined arg.
	 * @param[in] cb pointer to callback function.
	 * @return if 0, ok, else nok.
	 * @note
	TSDEV_API
		tsdev_api_unreg_tsmsg_receive_callback(tsdev_handle_t handle, void* usr_arg,
			tsdev_tsmsg_receive_callback_t cb);
	 */
	/**
	 * @brief register tsmessage type callback function for tsmsg rx type xx.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] usr_arg pointer to user defined arg.
	 * @param[in] type tsmessage type
	 * 0 ~ 127: system type
	 * 128 ~ 254: user defined type
	 * 255: all types.
	 * @param[in] cb pointer to callback funciton.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API  tsdev_api_reg_tsmsg_type_receive_callback(
		tsdev_handle_t handle, void* usr_arg, uint8_t type,
		tsdev_tsmsg_type_receive_callback_t cb);
	/**
	 * @brief unregister tsmessage type callback function for tsmsg rx type xx.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] usr_arg pointer to user defined arg.
	 * @param[in] type tsmessage type
	 * 0 ~ 127: system type
	 * 128 ~ 254: user defined type
	 * 255: all types.
	 * @param[in] cb pointer to callback funciton.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API  tsdev_api_unreg_tsmsg_type_receive_callback(
		tsdev_handle_t handle, void* usr_arg, uint8_t type,
		tsdev_tsmsg_type_receive_callback_t cb);
	/**
	 * @brief register fdid callback function for tsmsg rx type xx.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] usr_arg pointer to user defined arg.
	 * @param[in] fdid api's data id.
	 * @param[in] cb pointer to callback funciton.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API  tsdev_api_reg_tsmsg_fdid_hw_receive_callback(
		tsdev_handle_t handle, void* usr_arg, uint16_t fdid,
		tsdev_tsmsg_fdid_receive_callback_t cb);
	/**
	 * @brief unregister fdid callback function for tsmsg rx type xx.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] usr_arg pointer to user defined arg.
	 * @param[in] fdid api's data id.
	 * @param[in] cb pointer to callback funciton.
	 * @return if 0, ok, else nok.
	 * @note
	 */
	TSDEV_API  tsdev_api_unreg_tsmsg_fdid_hw_receive_callback(
		tsdev_handle_t handle, void* usr_arg, uint16_t fdid,
		tsdev_tsmsg_fdid_receive_callback_t cb);
	TSDEV_API  tsdev_api_unreg_all_tsmsg_fdid_hw_receive_callback(
		tsdev_handle_t handle, uint16_t fdid);


	TSDEV_API  tsdev_api_reg_tsmsg_fdid_pc_receive_callback(
		tsdev_handle_t handle, void* usr_arg, uint16_t fdid,
		tsdev_tsmsg_fdid_receive_callback_t cb);

	TSDEV_API  tsdev_api_unreg_tsmsg_fdid_pc_receive_callback(
		tsdev_handle_t handle, void* usr_arg, uint16_t fdid,
		tsdev_tsmsg_fdid_receive_callback_t cb);
	/**
	 * @brief register global callback function for tsmsg rx.
	 * @param[in] handle pointer to tsdev api handle.
	 * @param[in] msg pointer to tsmessage.
	 * @return if 0, ok, else nok.
	 * @note
	 * !!! msg should be freed (tsdev_api_mem_free()) by caller after
	 * processing.
	 
	TSDEV_API tsdev_api_tsmsg_receive(tsdev_handle_t handle, void* usr_arg, uint32_t max_rx_cnt,
			tsdev_tsmsg_receive_callback_t frame_handle);
			*/
#endif


#ifdef __cplusplus
}
#endif

#endif
