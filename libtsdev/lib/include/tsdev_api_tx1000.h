/**
 * Copyright (c) 2026:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef TSDEV_API_TX1000_H
#define TSDEV_API_TX1000_H

#include "tsdev_types.h"
#include "tsdev_api_tx1000_types.h"


#ifdef __cplusplus
extern "C"
{
#endif
    typedef int (*tsdev_DebugPortErrorEvent)(tsdev_handle_t handle, void* usr_arg, uint32_t channel, uint32_t ErrorCode);
    /**/

    /**
     * @brief Initialize the debugport.
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] timeout_ms Set Sync Request TimeOut [uint]:ms
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_init(tsdev_handle_t handle, uint32_t timeout_ms);

    

    /**
     * @brief uninitial the debugport.
     * @param[in] handle pointer to tsdev api handle.
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_uninit(tsdev_handle_t handle);


    /**
     * @brief configure Target channel chip_type,Frequency,DebugProcotol and sub_mode(if the chip_type have Submode).
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] channel choose target channel
     * @param[in] freq set target Frequency unit(Hz)
     * @param[in] procotol set DebugPort Protocol
     * @param[in] sub_mode If the debugging protocol has a submode, input the value of the submode, if no,input 0
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_target_set_sync(tsdev_handle_t handle,
        uint32_t channel, tsdev_tx1000_DebugPortChipType chip_type,
        uint32_t freq, tsdev_tx1000_DebugPortProtocol procotol, tsdev_tx1000_DebugPortDapSubProtocol sub_mode);

    /**
     * @brief halt target channel CPU.
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] channel choose target channel
     * @param[in] cpu_sel choose halt CPU number;if cpu_sel is 0xffffffff halt all target channel CPU
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_halt_cpu_sync(tsdev_handle_t handle,
        uint32_t channel, uint32_t cpu_sel);

    /**
     * @brief resume target channel CPU.
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] channel choose target channel
     * @param[in] cpu_sel choose resume CPU number;if cpu_sel is 0xffffffff halt all target channel CPU
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_resume_cpu_sync(tsdev_handle_t handle,
        uint32_t channel, uint32_t cpu_sel);

    /**
     * @brief Set target channel CPU PC register.
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] channel choose target channel
     * @param[in] cpu_sel choose CPU number;if cpu_sel is 0xffffffff halt all target channel CPU
     * @param[in] PC PC value
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_set_pc_sync(tsdev_handle_t handle,
        uint32_t channel, uint32_t cpu_sel, uint64_t PC);

    /**
     * @brief Make Target channel debugport Connect Chip.
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] channel choose target channel
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_connect_sync(tsdev_handle_t handle,
        uint32_t channel);

    /**
     * @brief Make Target channel debugport Disconnect with Chip.
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] channel choose target channel
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_disconnect_sync(tsdev_handle_t handle, uint32_t channel);

    /**
     * @brief Read Target channel Memory .
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] channel choose target channel
     * @param[in] addr Read Memory Data address
     * @param[out] readbuf output Memory Data
     * @param[in] len Read Memory Data length
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_read_mem_sync(tsdev_handle_t handle,
        uint32_t channel, uint64_t addr,
        uint8_t* readbuf, uint32_t len);

    /**
     * @brief Write Target channel Memory .
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] channel choose target channel
     * @param[in] addr Read Memory Data address
     * @param[in] writebuf input Memory Data
     * @param[in] len Read Memory Data length
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_tx1000_write_mem_sync(tsdev_handle_t handle,
        uint32_t channel, uint64_t addr,
        uint8_t* writebuf, uint32_t len);
    /**
     * @brief set xcp ring base addr
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] addr mcu xcp ring addr
     * @param[in] version mcu xcp ring version
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_xcp_set_mcu_ring_addr_sync(tsdev_handle_t handle,
        uint32_t addr, uint32_t* version);
    /**
     * @brief Send xcp cmd or data
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] writebuf write xcp tx frame
     * @param[in] len Read Memory Data length
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_xcp_tx_cmd_data(tsdev_handle_t handle,
        uint8_t core_idx, uint8_t* writebuf, uint32_t len);
    /**
     * @brief register xcp recieve callback.
     * @param[in] handle pointer to tsdev api handle.
     * @param[in] usr_arg pointer to user defined arg.
     * @param[in] event_func xcp recieve callback
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_xcp_rx_event_register(tsdev_handle_t handle, void* usr_arg, const xcp_rx_callback_t event_func);
    /**
     * @brief unregister xcp recieve callback.
     * @param[in] handle pointer to tsdev api handle.
     * @return if 0, ok, else nok.
     * @note
     */
    TSDEV_API tsdev_api_xcp_rx_event_unregister(tsdev_handle_t handle, const xcp_rx_callback_t event_func);

    TSDEV_API tsdev_api_tx1000_set_xcp_host_mode(tsdev_handle_t handle, uint16_t* event_cycle_ms, struct xcp_init_pars_t* xcp_pars);
#ifdef __cplusplus
}
#endif

#endif
