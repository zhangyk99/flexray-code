/**
 * Copyright (c) 2026:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_FLEXRAY_TYPES_H
#define __TSDEV_API_FLEXRAY_TYPES_H
#include "tsdev_api_base_types.h"

typedef tsdev_err_t (*tsdev_flexray_cmd_resp_event_t)(tsdev_handle_t handle, void *usr_arg, tsdev_tsmsg_t msg,
                                                      uint16_t rev, uint16_t fsize, const struct tsdev_THW_FlexrayResp *data);
typedef tsdev_err_t (*tsdev_flexray_frame_event_t)(tsdev_handle_t handle, void *usr_arg, tsdev_tsmsg_t msg,
                                                   uint16_t rev, uint16_t fsize, const struct tsdev_flexray_frame *data);

struct tsdev_flexray_controller_config
{
    uint8_t NETWORK_MANAGEMENT_VECTOR_LENGTH;
    uint8_t PAYLOAD_LENGTH_STATIC;
    uint16_t REVERS_16;
    uint16_t LATEST_TX;
    // __ prtc1Control
    uint16_t T_S_S_TRANSMITTER;
    uint8_t CAS_RX_LOW_MAX;
    uint8_t SPEED; // 0for 10m, 1 for 5m, 2 for 2.5m
    uint16_t WAKE_UP_SYMBOL_RX_WINDOW;
    uint8_t WAKE_UP_PATTERN;
    // __ prtc2Control
    uint8_t WAKE_UP_SYMBOL_RX_IDLE;
    uint8_t WAKE_UP_SYMBOL_RX_LOW;
    uint8_t WAKE_UP_SYMBOL_TX_IDLE;
    uint8_t WAKE_UP_SYMBOL_TX_LOW;
    // __ succ1Config
    uint8_t channelAConnectedNode;     // Whether to enable channel A, 0 does not start, 1 starts
    uint8_t channelBConnectedNode;     // Whether to enable channel B, 0 does not start, 1 starts
    uint8_t channelASymbolTransmitted; // Whether to enable the symbol transmission function of channel A, 0 does not start, 1 starts
    uint8_t channelBSymbolTransmitted; // Whether to enable the symbol transmission function of channel B, 0 does not start, 1 starts
    uint8_t ALLOW_HALT_DUE_TO_CLOCK;
    uint8_t SINGLE_SLOT_ENABLED; // FALSE_0, TRUE_1
    uint8_t wake_up_idx;         // Wake up channel selection, 0_channel A, 1-channel B
    uint8_t ALLOW_PASSIVE_TO_ACTIVE;
    uint8_t COLD_START_ATTEMPTS;
    uint8_t synchFrameTransmitted;   // Does this node need to send synchronization messages
    uint8_t startupFrameTransmitted; // Does this node need to send a startup message
    // __ succ2Config
    uint32_t LISTEN_TIMEOUT;
    uint8_t LISTEN_NOISE; // 2_16
    // __ succ3Config
    uint8_t MAX_WITHOUT_CLOCK_CORRECTION_PASSIVE;
    uint8_t MAX_WITHOUT_CLOCK_CORRECTION_FATAL;
    uint8_t REVERS0; // rev
    // __ gtuConfig
    // __ gtu01Config
    uint32_t MICRO_PER_CYCLE;
    // __ gtu02Config
    uint16_t Macro_Per_Cycle;
    uint8_t SYNC_NODE_MAX;
    uint8_t REVERS1; // rev
    // __ gtu03Config
    uint8_t MICRO_INITIAL_OFFSET_A;
    uint8_t MICRO_INITIAL_OFFSET_B;
    uint8_t MACRO_INITIAL_OFFSET_A;
    uint8_t MACRO_INITIAL_OFFSET_B;
    // __ gtu04Config
    uint16_t N_I_T;
    uint16_t OFFSET_CORRECTION_START;
    // __ gtu05Config
    uint8_t DELAY_COMPENSATION_A;
    uint8_t DELAY_COMPENSATION_B;
    uint8_t CLUSTER_DRIFT_DAMPING;
    uint8_t DECODING_CORRECTION;
    // __ gtu06Config
    uint16_t ACCEPTED_STARTUP_RANGE;
    uint16_t MAX_DRIFT;
    // __ gtu07Config
    uint16_t STATIC_SLOT;
    uint16_t NUMBER_OF_STATIC_SLOTS;
    // __ gtu08Config
    uint8_t MINISLOT;
    uint8_t REVERS2; // rev
    uint16_t NUMBER_OF_MINISLOTS;
    // __ gtu09Config
    uint8_t DYNAMIC_SLOT_IDLE_PHASE;
    uint8_t ACTION_POINT_OFFSET;
    uint8_t MINISLOT_ACTION_POINT_OFFSET;
    uint8_t REVERS3; // rev
    // __ gtu10Config
    uint16_t OFFSET_CORRECTION_OUT;
    uint16_t RATE_CORRECTION_OUT;
    // __ gtu11Config
    int8_t EXTERN_OFFSET_CORRECTION;
    int8_t EXTERN_RATE_CORRECTION;

    uint8_t config_byte1; // Bit0:1: Automatic restart after channel enters halt 0: Not enabled
    uint8_t config_byte;  // Bit0: 1: Enable terminal resistance on cha 0: Not enabled
    // Bit1: 1: Enable terminal resistance on CHB 0: Not enabled
    // Bit2: 1: Enable receive FIFO 0: Do not enable
    // Bit3: 1: FIFO supports receiving static frames (FIFO is invalid when not enabled, it is recommended to enable todo by default) 0: Not enabled
    // Bit4: 1: cha bridging enabled 0: not enabled
    // Bit5: 1: chb bridging enabled 0: not enabled
    // Bit6: 1: FIFO supports receiving empty frames (FIFO is invalid when not enabled, it is recommended to disable todo by default) 0: Not enabled
    // Bit7: 1: Send wakeup pattern when starting the network 0: Do not send wakeup pattern when starting the network
};
// Note that if the receive FIFO is enabled, the last ERAY_RX_FIFO_DEPTH trigglers will be unavailable
#define ERAY_MAX_TX_RX_TRIGGER_CNT 128
#define ERAY_RX_FIFO_DEPTH 4

// Note that the configuration of message triggers has the following requirements:
// 1.  The cold start message must be the first frame (if any)
// 2.  The synchronization message must be 1/2 frame (if any)
// 3.  Slot IDs increase in ascending order
struct tsdev_flexray_frame_config
{
    uint16_t frame_cnt;   // How many frame_rengths are there corresponding to
    uint16_t trigger_cnt; // How many triggers are there corresponding to

    uint8_t frame_length[ERAY_MAX_TX_RX_TRIGGER_CNT]; // BYTE-LENGTH

    uint16_t slot_id[ERAY_MAX_TX_RX_TRIGGER_CNT];
    uint8_t frame_length_idx[ERAY_MAX_TX_RX_TRIGGER_CNT];
    uint8_t cycle_code[ERAY_MAX_TX_RX_TRIGGER_CNT]; // BASE-CYCLE + CYCLE-REPETITION
    uint8_t config_byte[ERAY_MAX_TX_RX_TRIGGER_CNT];
    // Bit 0: Enable channel A or not
    // Bit 1: Is channel B enabled
    // Bit 2: Whether it is a network management message, regardless of whether dir is rx
    // Bit 3: Transmission mode, 0 represents continuous transmission, 1 represents single trigger, regardless of dir being rx
    // Bit 4: Whether it is a cold start message, only buffer 0 can be set to 1, regardless of dir being rx
    // Bit 5: Whether it is a synchronous message, only buffer 0/1 can be set to 1, regardless of dir being rx
    // bit 6:dir: 0-tx  1-rx
    // bit 7:
    uint8_t rev_byte[ERAY_MAX_TX_RX_TRIGGER_CNT];
};

struct tsdev_TPC_FlexrayConfig
{
    uint8_t node_idx;
    uint8_t type;       // 0for both, 1 for controler, 2 for frame
    uint8_t rev[4 + 2]; // var add 2024-8-16
    struct tsdev_flexray_controller_config controllerConfig;
    struct tsdev_flexray_frame_config frameConfig;
}; // 988 byte

struct tsdev_TPC_FlexrayCmdReq // min size is 8byte
{
    uint8_t node_idx;
    // 0: Stop flexray ok, 1: Start flexray ok, 2- Erase controller and message configuration, 3- Actively send wakup pattern, not guaranteed to be able to send
    // 4- Change trigger status (unable to change cold start message status)
    // 5: Read register ok, write register ok 6, modify header crc 7 (unable to change cold start message crc)
    uint8_t action;
    uint8_t rev[4 + 2]; // var add 2024-8-16
    union FlexrayCmdReq_pars
    {
        struct FlexrayCmdReq_act4
        {
            uint16_t slot_id;
            uint8_t cycle_base;
            uint8_t cycle_rep;
            uint8_t is_enable;
            uint8_t rev[3];
        } act4;
        struct FlexrayCmdReq_act5
        {
            uint32_t reg_addr;
        } act5;
        struct FlexrayCmdReq_act6
        {
            uint32_t reg_addr;
            uint32_t reg_val;
        } act6;
        struct FlexrayCmdReq_act7
        {
            uint16_t slot_id;
            uint8_t cycle_base;
            uint8_t cycle_rep;
            uint16_t header_crc;   // is_change_crc!= At 0, use this CRC value
            uint8_t is_change_crc; // 0: restore crc 1: change crc
            uint8_t rev;
        } act7;
        struct FlexrayCmdReq_rev
        {
            uint8_t data[12];
            uint8_t rev[4];
        } revs;
    } pars;
};

#define FLEXRAY_FRAME_SIZE 302
struct tsdev_flexray_frame
{
    uint8_t FIdxChn;              // channel index starting from 0
    uint8_t FChannelMask;         // bit 0: cha, bit1: chb
                                  // Bit2: 1 message is sent sequentially after buffering, and 0 immediately updates the sending buffer
    uint8_t FDir;                 // 0: Rx, 1: Tx, 2: Tx Request
    uint8_t FPayloadLength;       // payload length in bytes
    uint8_t FActualPayloadLength; // actual data bytes
    uint8_t FCycleNumber;         // cycle number: 0~63
    uint8_t FCCType;              // not usd by tosun
    uint8_t FFrameType;           // // 0 = raw flexray frame, 1 = error event, 2 = status, 3 = start cycle
    uint16_t FHeaderCRCA;         // header crc A
    uint16_t FHeaderCRCB;         // header crc B
    uint16_t FFrameStateInfo;     // bit 0~15, error flags
    // bit0	syntax error	config_header[3]  SEOA | SEOB
    // bit1	Content Error	config_header[3]  CEOA | CEOB
    // bit2	Slot BoundaryViolation	config_header[3]  SVOA | SVOB
    // bit3	Empty Slot	config_header[3]  ESA | ESB
    // bit4	Message Lost	config_header[3]  MLST
    // bit5	Valid Frame	config_header[3]  VFRA==0&&VFRB==0
    // bit6	TX Conflict 	config_header[3]  TCIA | TCIB

    uint16_t FSlotId;     // static seg: 0~1023
    uint32_t FFrameFlags; // bit 0~22
    // 0 1 = Null frame.
    // 1 1 = Data segment contains valid data
    // 2 1 = Sync bit
    // 3 1 = Startup flag
    // 4 1 = Payload preamble bit
    // 5 1 = Reserved bit
    // 6 1 = Error flag(error frame or invalid frame)
    uint32_t FFrameCRC;  // frame crc
    uint64_t FReserved1; // 8 reserved bytes
    uint64_t FReserved2; // 8 reserved bytes
    uint64_t FTimeUs;    // timestamp in us

    union flexray_frame_pars
    {
        uint8_t FData[254]; // 54 data bytes, not aligned with 4 bytes here, but belongs to the end of the structure, so it does not affect, for FFrameType==0
        struct _TFlexRayStartCycleEvent
        {
            uint32_t FSyncCorrection;                // Sync correction of CC, read from	RCV register
            uint32_t FOffsetCorrection;              // Offset correction of CC, read from OCV register
            uint32_t FCyclesWithNoCorrection;        // Cycles with no correction, read from CCEV register
            uint32_t FCyclesWithCorrectionInPassive; // Cycles with correction in passive mode, read from CCEV register
            uint32_t FSyncFrameStatus;               // Sync Frame status, read from	SFS register
            uint16_t FNMVectorLength;                // Length of NM-Vector in bytes
            uint8_t FDataBytes[12];                  // Array of databytes (NM vector max. length)
            uint8_t rev[6];
        } start_cycle_event;
        struct _TFlexRayStatusEvent
        {
            uint32_t FPOCState;    // POC state of E-Ray register CCSV. Only valid for Vector interfaces
            uint32_t FWakeupState; // WakeUp state. Only valid for Vector interfacesand for Cyclone II, if symbol is void (mReserved[0] = 0)
            // 0 UNDEFINED
            // 1 RECEIVED_HEADER
            // 2 RECEIVED_WUP
            // 3 COLLISION_HEADER
            // 4 COLLISION_WUP
            // 5 COLLISION_UNKNOWN
            // 6 TRANSMITTED
            // 7 EXTERNAL_WAKEUP
            // 8 WUP_RECEIVED_WITHOUT_WUS_TX
            uint32_t FSyncState; // Sync-State, only valid for Cyclone 1, for Cyclone II if the wakup state value is 0
            // 0 = Not synced passive
            // 1 = Synced active
            // 2 = Not synced
            uint16_t FSymbol; // 0: void, 1: CAS, 2: MTS, 3: WUS
            uint16_t rev;     // var add 2024-8-16
        } status_event;
        struct _TFlexRayErrorEvent
        {
            uint8_t FErrorTag;
            uint8_t FErrorData1[4];
            uint8_t FErrorData2[4];
            uint8_t rev[7]; // var add 2024-8-16
        } error_event;
    } pars;
};

// Reply to relevant REQ
struct tsdev_THW_FlexrayResp // min size is 12byte
{
    uint8_t action; // req<->action
    uint8_t rev0;
    uint8_t node_idx;
    uint8_t result;  // 0 for ok, other for fail
    uint8_t rev1[4]; // var add 2024-8-16
    union FlexrayResp_pars
    {
        struct FlexrayResp_act5
        {
            uint32_t reg_val;
            uint32_t rev;
        } act5;
        struct FlexrayResp_rev
        {
            uint8_t data[40];
        } revs;
    } pars;
};

#endif // __TSDEV_API_FLEXRAY_TYPES_H
