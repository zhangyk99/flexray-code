/**
 * Copyright (c) 2025:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_CAN_UDS_TYPES_H__
#define __TSDEV_API_CAN_UDS_TYPES_H__

#include "tsdev_api_base_types.h"

struct tsdev_can_uds_apply_info_t
{
    uint32_t reqid;
    uint32_t resid;
    uint32_t funcid;
    uint8_t chn_idx;
    uint8_t rev[3];
};

struct tsdev_can_uds_config_t
{
    uint32_t FReqID;
    uint32_t FResID;
    uint32_t FFunctionalID;
    uint8_t FIsReqIDStandard;
    uint8_t FIsResIDStandard;
    uint8_t FIsFunctionalIDStandard;
    // uint8_t FIdxChn; not needed
    uint8_t FFilledByte;
    uint8_t FAtLeast8Bytes;
    uint8_t FIsFD;
    uint8_t FIsFDBRS;
    uint8_t FMaxDLCofFDFrame;
    uint8_t N_WFTmax;
    uint16_t FReserved01; // 24
    uint32_t FSTMin;      // float FSTMin;
    uint16_t FReserved02;
    uint8_t FUserDefinedTxSTMin;
    uint8_t FUserDefinedFCDelay; // 4
    uint32_t FTxSTMin;           // float FTxSTMin;
    uint32_t FFCDelayMs;         // float FFCDelayMs;
    uint32_t FBlockSize;
    uint32_t FMaxLength; // 8 + 12
    uint16_t N_As;       // Maximum time for the sender to transmit data to the receiver, default 1000
    uint16_t N_Ar;       // Maximum time for the receiver to transmit flow control to the sender, default 1000
    uint16_t N_Bs;       // The maximum time that the sender receives a flow controll frame after successfully sending the first frame, 1000 by default.
    uint16_t N_Br;       // Maximum time between receiving end and sending flow control after receiving the first frame
    uint16_t N_Cs;       // Maximum time that the receiving end controls the sending flow to the receiving end
    uint16_t N_Cr;       // The maximum time from sending successful flow control to receiving continuous frames, 1000 by default.
};

enum tsdev_can_uds_error_code_t
{
    tsdev_can_uds_N_OK = 0,
    tsdev_can_uds_N_TIMEOUT_A,
    tsdev_can_uds_N_TIMEOUT_BS,
    tsdev_can_uds_N_TIMEOUT_CR,
    tsdev_can_uds_N_WRONG_SN,
    tsdev_can_uds_N_INVALID_FS,
    tsdev_can_uds_N_UNEXP_PDU,
    tsdev_can_uds_N_WFT_OVRN,
    tsdev_can_uds_N_BUFFER_OVFLW,
    tsdev_can_uds_N_ERROR,
};

typedef uint64_t tsdev_can_uds_handle_t;

typedef void (*can_uds_message_callback_t)(tsdev_handle_t handle, uint32_t frame_id,
                                           const uint8_t *data_p, uint32_t data_len, int err_code);

#endif