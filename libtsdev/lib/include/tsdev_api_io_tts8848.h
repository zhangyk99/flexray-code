/**
 * Copyright (c) 2026:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_IO_TTS8848_H
#define __TSDEV_API_IO_TTS8848_H

#include "tsdev_types.h"
#include "tsdev_api_io_tts_common.h"
#ifdef __cplusplus
extern "C"
{
#endif


    //TTS8848
    union tsdev_dev_io_tts8848_cmd_resp {

        //all fealtures
        struct tsdev_dev_all_cmd0_resp0 {
            uint8_t  cmd;                       //tsdev_dev_io_tts_cmd_enum
            uint8_t  dev_idx;                   // Board ID
            uint8_t Ch1_48_do_v[6];             // Output level: 0=high, 1=low

            uint8_t  Ch1_32_ao_mode[8];         // 64-bit, 2 bits per channel (1-32): 0 push-pull; 1 high-side; 2 low-side
            uint8_t  Ch33_48_ao_mode[8];        // 64-bit, 4 bits per channel (33-48)
            // 0: analog IO push-pull; 1: analog IO high-side; 2: analog IO low-side
            // 3: PWM push-pull; 4: PWM high-side; 5: PWM low-side
            // 6: bit-stream push-pull; 7: bit-stream high-side; 8: bit-stream low-side
            uint16_t ao_duty[16];               // Unit: 0.1%, range: 1~999
            uint32_t ao_hz[16];                 // Unit: 0.01%, range: 2~20000kHz

            uint16_t Ch33_48_ao_bit_write_en;   // Bit-stream write enable
            uint16_t Gp1_12_vref;               // Excitation voltage (4 channels per group): 0=VExt, 1=VBat
            uint16_t Gp1_vth[6];                // Threshold voltage (mV)

            uint16_t ao_bit_loop_count[16];     // Bit-stream loop count: 0~65535, 0=infinite
            uint16_t ao_bit_pause_time[16];     // Bit-stream interval (us)
            int32_t  ao_bit_time[16];           // Bit-stream duration (us)
            uint16_t ao_bit_count[16];          // Bit-stream bit count: 2~4096
            uint8_t  ao_bit_start_time[16];     // Bit-stream start delay
            uint16_t ao_bit_start_point[16];    // Bit-stream start point: 0~4096
            uint32_t pwm_sample_time[16];       // PWM sampling time (us)
            uint64_t bit_data[64];              // Bit-stream data (shared across channels)
            uint8_t Ch1_48_ao_en[6];            // Output channel enable
        }init_setup;

        //common feature
        tts_cmd1_resp1   voltage_lvl;         //voltage_lvl      
        tts_cmd2_resp2   voltage_cmp;         //voltage_cmp   
        tts_cmd4_resp4   dido_mode;           //dido_mode        
        tts_cmd5_resp5   dido_status;         //dido_status      
        tts_cmd6_resp6   pwm_write;      	  //pwm_write 
	    tts_cmd6_resp6   pwm_read;      	  //pwm_read   
        tts_cmd7_resp7   bit_stream_write;    //bit_stream_write
        tts_cmd8_resp8   bit_stream_read;     //bit_stream_read  
    };


    // max 48 channels
    union tsdev_dev_io_tts8848_daq_resp {
    uint8_t rev[1024];
    struct tsdev_dev_tts_dido_resp9 {
        uint64_t timestamp;
        uint8_t cmd;	                //tsdev_dev_io_tts8848_cmd_enum
        uint8_t cnt;                    // rolling cnt
        uint8_t io_status[6];           //one bit per channel
    }dido_status;
    //pwm
    struct tsdev_dev_tts_dido_resp10 {
        uint64_t timestamp;
        uint8_t cmd;	                //tsdev_dev_io_tts8848_cmd_enum
        uint8_t cnt;
        uint8_t pwm_data_cnt;
        uint8_t rev[5];
        struct tsdev_dev_tts_dido_pwm_data_t
        {
            uint8_t ch_idx;
            uint8_t rev;
            uint16_t duty;              //uint is 0.1%
            uint32_t freq;              //unit is 0.01hz
        } data[16];
    }dido_pwm;

    //bit stream 
    struct tsdev_dev_tts_dido_resp11 {
        uint64_t timestamp;
        uint8_t cmd;	                //tsdev_dev_io_tts8848_cmd_enum
        uint8_t cnt;
        uint8_t rev[6];
        struct tsdev_dev_dido_bit_data_t
        {
            uint8_t ch_idx;
            uint8_t rev[3];
            uint32_t bit_data;
        } data[16];
    }dido_bit_stream;
};


    typedef tsdev_err_t (*tsdev_io_tts8848_cmd_event_t)(tsdev_handle_t handle, void *usr_arg, tsdev_tsmsg_t msg,
                                            uint16_t rev, uint16_t fsize, const union tsdev_dev_io_tts8848_cmd_resp *resp);
    typedef tsdev_err_t (*tsdev_io_tts8848_daq_event_t)(tsdev_handle_t handle, void *usr_arg, tsdev_tsmsg_t msg,
                                            uint16_t rev, uint16_t fsize, const union tsdev_dev_io_tts8848_daq_resp *daq);



	TSDEV_API tsdev_api_io_tts8848_cmd_async(tsdev_handle_t handle,
									 const union tsdev_dev_io_tts8848_cmd_resp *cmd);

	TSDEV_API tsdev_api_io_tts8848_cmd_reg_event(tsdev_handle_t handle,
										 void *usr_arg,
										 const tsdev_io_tts8848_cmd_event_t event);
	TSDEV_API tsdev_api_io_tts8848_cmd_unreg_event(tsdev_handle_t handle,
										   void *usr_arg,
										   const tsdev_io_tts8848_cmd_event_t event);

	TSDEV_API tsdev_api_io_tts8848_cmd_unreg_events(tsdev_handle_t handle);

	TSDEV_API tsdev_api_io_tts8848_daq_reg_event(tsdev_handle_t handle,
										 void *usr_arg,
										 const tsdev_io_tts8848_daq_event_t event);
	TSDEV_API tsdev_api_io_tts8848_daq_unreg_event(tsdev_handle_t handle,
										   void *usr_arg,
										   const tsdev_io_tts8848_daq_event_t event);
	TSDEV_API tsdev_api_io_tts8848_daq_unreg_events(tsdev_handle_t handle);

#ifdef __cplusplus
}
#endif

#endif