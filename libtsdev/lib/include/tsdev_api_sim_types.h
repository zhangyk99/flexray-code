/**
 * Copyright (c) 2025:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_SIM_TYPES_H
#define __TSDEV_API_SIM_TYPES_H

#include "tsdev_api_base_types.h"

#define TSDEV_SIM_LAYOUT_VERSION (2U)


enum tsdev_sig_type {
	tsdev_sig_u8
	, tsdev_sig_u16
	, tsdev_sig_u32
	, tsdev_sig_u64
	, tsdev_sig_s8
	, tsdev_sig_s16
	, tsdev_sig_s32
	, tsdev_sig_s64
	, tsdev_sig_float32
	, tsdev_sig_float64
};
enum tsdev_sig_cov_type {
	tsdev_sig_cov_none
	, tsdev_sig_cov_linear
	, tsdev_sig_cov_poly
	, tsdev_sig_cov_table
	, tsdev_sig_cov_rational
	, tsdev_sig_cov_exp
	, tsdev_sig_cov_log
	, tsdev_sig_cov_enum_map
};
typedef float float32_t;
typedef double float64_t;
typedef union tsdev_cal_sig_val_u_t {
	uint8_t u8_val;
	uint16_t u16_val;
	uint32_t u32_val;
	uint64_t u64_val;
	int8_t s8_val;
	int16_t s16_val;
	int32_t s32_val;
	int64_t s64_val;
	float32_t f32_val;
	float64_t f64_val;
}tsdev_cal_sig_val_t;
typedef enum {
	TSDEV_DIM_STATIC,
	TSDEV_DIM_SIGNAL_REF,
	TSDEV_DIM_AXIS_PTS_REF
} tsdev_dim_type_t;
typedef struct {
	uint8_t type; //ref tsdev_dim_type_t
	uint8_t rev;
	uint16_t static_size;
	uint16_t signal_id; //ref to signal index
	uint16_t axis_id; //ref to signal index
} tsdev_sig_dim_t;

enum tsdev_cal_sig_config_kind {
	TSDEV_CAL_SIG_CFG_SIGNAL = 0,
	TSDEV_CAL_SIG_CFG_ROOT_INPUT = 1,
	TSDEV_CAL_SIG_CFG_ROOT_OUTPUT = 2,
	TSDEV_CAL_SIG_CFG_BLOCK_PARAMETER = 3,
	TSDEV_CAL_SIG_CFG_MODEL_PARAMETER = 4,
	TSDEV_CAL_SIG_CFG_STATE = 5,
};
#define TSDEV_CAL_SIG_CFG_KIND_MASK (0x0F)
struct tsdev_cal_sig_def_t {
	char name[32];
	//ref to enum tsdev_cal_sig_type
	uint8_t sig_type;
	// ref to enum tsdev_cal_cov_type
	uint8_t cov_type;
	// lower 4 bits follow enum tsdev_cal_sig_config_kind
	uint8_t config;
	uint8_t dim_cnt; //0-4
	uint32_t rev1;
	tsdev_sig_dim_t dims[4];
	tsdev_cal_sig_val_t default_val;
	tsdev_cal_sig_val_t invaild_val;
	tsdev_cal_sig_val_t max_val;
	tsdev_cal_sig_val_t min_val;
	union tsdev_cal_sig_def_addr_t
	{
		uint64_t val;
		void* ptr;
	}addr_u;
	uint32_t addr_offset; //xcp should use this var as cal address
	uint32_t rev2;
	union tsdev_cal_sig_cov_par_t {
		uint8_t rev[8 * 6];
		//phy = a*raw+b
		struct tsdev_cal_sig_cov_linear {
			float64_t a;
			float64_t b;
		}linear;
		// phy = c0 + c1*raw + c2*raw^2 + ... + cn*raw^n
		struct tsdev_cal_sig_cov_polynomial {
			uint8_t degree;     // (1-5)
			float64_t coeffs[6];// [c0, c1, c2, c3, c4, c5]
		} poly;
		struct tsdev_cal_sig_cov_table {
			uint16_t table_id;  //ref to signal index
			uint8_t interp_type;//0=nearest neighbor, 1=linear, 2=cubic spline
		} table;
		//phy = (a + b*raw) / (1 + c*raw + d*raw^2)
		struct tsdev_cal_sig_cov_rational {
			float64_t a;
			float64_t b;
			float64_t c;
			float64_t d;
		} rational;
		//phy = a * exp(b * raw) + c
		struct tsdev_cal_sig_cov_exponential {
			float64_t a;
			float64_t b;
			float64_t c;
		} exp;
		//phy = a * log(b * raw + c) + d
		struct tsdev_cal_sig_cov_logarithmic {
			float64_t a;
			float64_t b;
			float64_t c;
			float64_t d;
		}log;
		struct tsdev_cal_sig_cov_enum {
			uint16_t num_states;
			struct {
				uint32_t raw_value;
				char* name;
			} states[128];
		} enum_map;
	}cov;
};//xcp_id is not used, signal index is xcp_id

typedef enum tsdev_sim_model_type {
	TSDEV_SIM_MODEL_UNKNOWN = 0,
	TSDEV_SIM_MODEL_USER_MODULE = 1,
	TSDEV_SIM_MODEL_MATLAB = 2
} tsdev_sim_model_type_t;

struct tsdev_sim_layout_overview_t {
	uint8_t version;
	uint8_t is_loaded;
	uint8_t component_cnt;
	uint8_t core_configured;
	uint8_t reserved;
	uint32_t cycle_us_default;
	uint32_t sim_start_delay_us;
	uint32_t share_mem_size;
	const char* entry_path;
	const char* config_path;
};

struct tsdev_sim_component_desc_t {
	uint8_t component_idx;
	uint8_t core_span;
	tsdev_sim_model_type_t model_type;
	uint8_t reserved;
	const char* name;
	const char* dll_path;
	const char* model_prefix;
};

struct tsdev_sim_thread_desc_t {
	uint8_t thread_idx;
	uint8_t logical_core;
	uint8_t component_idx;
	uint8_t component_local_idx;
	tsdev_sim_model_type_t model_type;
	uint8_t reserved;
	const char* component_name;
	const char* dll_path;
	const char* model_prefix;
};

typedef tsdev_err_t(*tsdev_start_t)(tsdev_handle_t handle);
typedef tsdev_err_t(*tsdev_cycle_entry_pre_t)(tsdev_handle_t handle, uint64_t time_ns_now);
typedef tsdev_err_t(*tsdev_cycle_entry_t)(tsdev_handle_t handle, uint64_t time_ns_now);
typedef tsdev_err_t(*tsdev_cycle_entry_after_t)(tsdev_handle_t handle, uint64_t time_ns_now);
typedef tsdev_err_t(*tsdev_stop_t)(tsdev_handle_t handle);
typedef tsdev_err_t(*tsdev_sim_sig_update)(tsdev_handle_t handle, void* usr_arg, uint8_t core_idx
	, uint64_t time_us, const struct tsdev_cal_sig_def_t* sig_def, const tsdev_cal_sig_val_t* val);

typedef uint32_t tsdev_dp_group_id_t;   // Zero-based datapool group identifier
typedef uint32_t tsdev_dp_signal_id_t;  // Zero-based datapool signal identifier
#define TSDEV_DP_MAX_GROUP_NAME_LEN (64U)
typedef void* tsdev_dp_group_handle_t;

struct tsdev_dp_signal_entry {
	tsdev_dp_signal_id_t signal_id;
	uint32_t byte_offset;
};

#define TSDEV_DP_TARGET_BITMAP_BYTES          (6U)
#define TSDEV_DP_TARGET_MAX_RT_CORES          (47U)
#define TSDEV_DP_TARGET_NON_RT_BIT_INDEX      (47U)
#define TSDEV_DP_TARGET_NON_RT_BYTE_INDEX     (TSDEV_DP_TARGET_NON_RT_BIT_INDEX >> 3)
#define TSDEV_DP_TARGET_NON_RT_BIT_OFFSET     (TSDEV_DP_TARGET_NON_RT_BIT_INDEX & 0x7U)
#define TSDEV_DP_TARGET_RT_ALL_MASK           (0x7FFFFFFFFFFFULL)
#define TSDEV_DP_TARGET_NON_RT_MASK           (1ULL << TSDEV_DP_TARGET_NON_RT_BIT_INDEX)

#define TSDEV_DP_TARGET_BITMAP_CLEAR(bmp) \
	do { \
		(bmp)[0] = 0U; \
		(bmp)[1] = 0U; \
		(bmp)[2] = 0U; \
		(bmp)[3] = 0U; \
		(bmp)[4] = 0U; \
		(bmp)[5] = 0U; \
	} while (0)

#define TSDEV_DP_TARGET_BITMAP_SET_RT(bmp, idx) \
	do { \
		if ((idx) < TSDEV_DP_TARGET_MAX_RT_CORES) { \
			uint8_t _byte_idx = (uint8_t)((idx) >> 3); \
			uint8_t _bit_mask = (uint8_t)(1U << ((idx) & 0x7U)); \
			(bmp)[_byte_idx] = (uint8_t)((bmp)[_byte_idx] | _bit_mask); \
		} \
	} while (0)

#define TSDEV_DP_TARGET_BITMAP_HAS_RT(bmp, idx) \
	(((idx) < TSDEV_DP_TARGET_MAX_RT_CORES) ? \
		(((bmp)[(idx) >> 3] >> ((idx) & 0x7U)) & 0x1U) : 0U)

#define TSDEV_DP_TARGET_BITMAP_SET_NON_RT(bmp) \
	do { \
		(bmp)[TSDEV_DP_TARGET_NON_RT_BYTE_INDEX] = \
			(uint8_t)((bmp)[TSDEV_DP_TARGET_NON_RT_BYTE_INDEX] | \
				(uint8_t)(1U << TSDEV_DP_TARGET_NON_RT_BIT_OFFSET)); \
	} while (0)

#define TSDEV_DP_TARGET_BITMAP_HAS_NON_RT(bmp) \
	(((bmp)[TSDEV_DP_TARGET_NON_RT_BYTE_INDEX] >> TSDEV_DP_TARGET_NON_RT_BIT_OFFSET) & 0x1U)

struct tsdev_dp_group_desc {
	tsdev_dp_group_id_t group_id;
	uint16_t signal_count;
	uint8_t thread_idx;//not used for usr group
	uint8_t component_idx;//not used for usr group
	uint8_t config_kind;
	uint8_t publish_enabled;
	uint8_t publish_reserved[2];
	char name[TSDEV_DP_MAX_GROUP_NAME_LEN];
	const struct tsdev_dp_signal_entry* signals;
	uint8_t publish_target_bitmap[TSDEV_DP_TARGET_BITMAP_BYTES];
};

struct tsdev_dp_pool_static_cfg {
	uint32_t revision;
	uint32_t group_count;
	const struct tsdev_dp_group_desc* groups;
};

#define TSDEV_DP_GROUP_PUBLISH_TYPE_MASK      (0x8000U)
#define TSDEV_DP_GROUP_PUBLISH_COUNT_MASK     (0x7FFFU)
#define TSDEV_DP_GROUP_PUBLISH_TYPE_GROUP     (0x0000U)
#define TSDEV_DP_GROUP_PUBLISH_TYPE_SIGNAL    (0x8000U)
#define TSDEV_DP_GROUP_PUBLISH_COUNT_MAX      (TSDEV_DP_GROUP_PUBLISH_COUNT_MASK)

#define TSDEV_DP_TARGET_BITMAP_LOAD(mask, bmp) \
	do { \
		(mask) = ((uint64_t)(bmp)[0]) | \
			(((uint64_t)(bmp)[1]) << 8U) | \
			(((uint64_t)(bmp)[2]) << 16U) | \
			(((uint64_t)(bmp)[3]) << 24U) | \
			(((uint64_t)(bmp)[4]) << 32U) | \
			(((uint64_t)(bmp)[5]) << 40U); \
	} while (0)

#define TSDEV_DP_TARGET_BITMAP_STORE(bmp, mask) \
	do { \
		(bmp)[0] = (uint8_t)((mask) & 0xFFU); \
		(bmp)[1] = (uint8_t)(((mask) >> 8U) & 0xFFU); \
		(bmp)[2] = (uint8_t)(((mask) >> 16U) & 0xFFU); \
		(bmp)[3] = (uint8_t)(((mask) >> 24U) & 0xFFU); \
		(bmp)[4] = (uint8_t)(((mask) >> 32U) & 0xFFU); \
		(bmp)[5] = (uint8_t)(((mask) >> 40U) & 0xFFU); \
	} while (0)

#define TSDEV_DP_TARGET_BITMAP_SET_ALL_RT(bmp) \
	TSDEV_DP_TARGET_BITMAP_STORE((bmp), TSDEV_DP_TARGET_RT_ALL_MASK)

#define TSDEV_DP_TARGET_BITMAP_SET_WIN_ONLY(bmp) \
	TSDEV_DP_TARGET_BITMAP_STORE((bmp), TSDEV_DP_TARGET_NON_RT_MASK)

#define TSDEV_DP_TARGET_BITMAP_IS_EMPTY(bmp) \
	(((bmp)[0] | (bmp)[1] | (bmp)[2] | (bmp)[3] | (bmp)[4] | (bmp)[5]) == 0U)

#define TSDEV_DP_GROUP_PUBLISH_SET_TYPE_AND_COUNT(header_ptr, type_flag, count_value) \
	do { \
		uint16_t _cnt_val = (uint16_t)((count_value) & TSDEV_DP_GROUP_PUBLISH_COUNT_MASK); \
		uint16_t _type_val = (uint16_t)(((type_flag) != 0U) ? TSDEV_DP_GROUP_PUBLISH_TYPE_SIGNAL : TSDEV_DP_GROUP_PUBLISH_TYPE_GROUP); \
		(header_ptr)->type_and_count = (uint16_t)(_cnt_val | _type_val); \
	} while (0)

#define TSDEV_DP_GROUP_PUBLISH_GET_TYPE(header_ptr) \
	(((header_ptr)->type_and_count & TSDEV_DP_GROUP_PUBLISH_TYPE_MASK) ? 1U : 0U)

#define TSDEV_DP_GROUP_PUBLISH_GET_COUNT(header_ptr) \
	((header_ptr)->type_and_count & TSDEV_DP_GROUP_PUBLISH_COUNT_MASK)

struct tsdev_dp_group_publish_header {
	uint16_t type_and_count;
	uint8_t target_bitmap[TSDEV_DP_TARGET_BITMAP_BYTES]; // bits 0-46 for RT cores, bit 47 for non-RT
	uint64_t timestamp_us;
	union tsdev_dp_group_publish_header_u {
		struct tsdev_dp_group_publish_header_groups {
			tsdev_dp_group_id_t group_id;
			uint32_t group_data_size;
		}v0[1];//ref group_cnt
		struct tsdev_dp_group_publish_header_signals {
			tsdev_dp_signal_id_t signal_id;
			uint32_t signal_data_size;
		}v1[1];//ref signal_cnt
	}h;
};
#define TSDEV_SIZE_OF_DP_HEADER_0(cnt) \
	(sizeof(struct tsdev_dp_group_publish_header)+(cnt-1)*(sizeof(struct tsdev_dp_group_publish_header_groups)))

#define TSDEV_SIZE_OF_DP_HEADER_1(cnt) \
	(sizeof(struct tsdev_dp_group_publish_header)+(cnt-1)*(sizeof(struct tsdev_dp_group_publish_header_signals)))

typedef tsdev_err_t(*tsdev_api_dp_group_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
	uint16_t rev, uint16_t fsize, const struct tsdev_dp_group_publish_header* data);



#endif
