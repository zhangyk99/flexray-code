/**
 * Copyright (c) 2026:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_ETH_TPES_H
#define __TSDEV_API_ETH_TPES_H

#include "tsdev_api_base_types.h"


 // refer to tsdevm_eth_config_t
struct tsdev_eth_config_t {
	uint8_t const_header; //=0x38
	uint8_t version;      // 0->did_0308_v0_t
	uint8_t force_set;    //==0x87 force set net
	uint8_t rev1[1 + 4]; //var add 2024-8-16
	struct tsdev_eth_config_v0_t {
		// bit0-5: 1-enable DHCP; 0-diable DHCP per port , refer to ip[6]   
		// bit6: rev
		// bit7: 1-save this config; 0-don't save this config
		uint8_t config;
		// bit0-5: 1-is ipv6; 0-is ipv4 , refer to ip[6]   
		uint8_t config1;
		// bit0-3: tcp_client_cnt 0-4
		// bit4-7: udp_client_cnt 0-4
		uint8_t config2;
		// bit0-3: tcp_client is ipv6, 1bit per client
		// bit4-7: udp_client is ipv6, 1bit per client
		uint8_t config3;
		// bit0-5: dhcp done or ip init done per port 
		//bit6-7: rev
		uint8_t status;
		uint8_t rev[1 + 4];//var add 2024-8-16
		// bit0-11: link speed 0-10m, 1-100m, 2-1000m, 3-10G, 2bit per port
		uint16_t link_status;
		uint16_t tcp_server_port;
		uint16_t udp_server_port;
		struct tsdev_eth_config_ip_v0_t {
			uint8_t addr[16];
			uint8_t mask[16];
			uint8_t gw[16];
			uint8_t dns[16];
		} ip[6];//assume one dev have at most 6 netif
		struct tsdev_eth_config_tcp_client_t {
			uint8_t target_ip[16];
			uint16_t target_port;
			uint8_t rev[2 + 4];//var add 2024-8-16
		} tcp_clients[4];
		struct tsdev_eth_config_udp_client_t {
			uint8_t target_ip[16];
			uint16_t target_port;
			uint8_t rev[2 + 4];//var add 2024-8-16
		} udp_clients[4];
	}v0_par;
};

//--------------------------------------------------------------for ethernet dev port----------------------------------------------------
enum tsdev_eth_fcmd_type_t
{
	tsdev_IDX_ETH_CMD_TYPE_Cfg_Eth_Chn = 0,
	tsdev_IDX_ETH_CMD_TYPE_Clear_Wakeup,
	tsdev_IDX_ETH_CMD_TYPE_Read_Chn_Status,
	tsdev_IDX_ETH_CMD_TYPE_ptp_cal,
	tsdev_IDX_ETH_CMD_TYPE_add_filter,
	tsdev_IDX_ETH_CMD_TYPE_read_filter_cnt,
	tsdev_IDX_ETH_CMD_TYPE_read_filter_by_idx,
	tsdev_IDX_ETH_CMD_TYPE_clean_filter,
	tsdev_IDX_ETH_CMD_TYPE_Stream_Gen_Ctrl,
	tsdev_IDX_ETH_CMD_TYPE_Stream_Pay_Cfg
};

struct tsdev_eth_filter_def_t {
	//0: dest mac addr
	//1: src mac addr
	//2: eth type
	//4: dest ipv4 addr
	//5: src ipv4 addr
	//6: vlan tci
	//7: dest ipv6 addr
	//8: src ipv6 addr
	uint8_t filter_type;
	uint8_t vlan_cnt;//0-4 are allowed
	uint8_t rev[6];
	uint16_t vlan_type0_mask;
	uint16_t vlan_type0_code;
	uint16_t vlan_type1_mask;
	uint16_t vlan_type1_code;
	uint16_t vlan_type2_mask;
	uint16_t vlan_type2_code;
	uint16_t vlan_type3_mask;
	uint16_t vlan_type3_code;

	uint8_t mask[16];
	uint8_t code[16];

	/* mask and code are one of
	uint8_t dest_mac_mask[6];
	uint8_t dest_mac_code[6];
	uint8_t src_mac_mask[6];
	uint8_t src_mac_code[6];
	uint16_t eth_type_mask;
	uint16_t eth_type_code;

	uint8_t dest_ipv4_addr_mask[4];
	uint8_t dest_ipv4_addr_code[4];
	uint8_t src_ipv4_addr_mask[4];
	uint8_t src_ipv4_addr_code[4];
	uint16_t dest_ipv4_port_mask;
	uint16_t dest_ipv4_port_code;
	uint16_t src_ipv4_port_mask;
	uint16_t src_ipv4_port_code;

	uint8_t dest_ipv6_addr_mask[4*4];
	uint8_t dest_ipv6_addr_code[4 * 4];
	uint8_t src_ipv6_addr_mask[4 * 4];
	uint8_t src_ipv6_addr_code[4 * 4];
	uint16_t dest_ipv6_port_mask;
	uint16_t dest_ipv6_port_code;
	uint16_t src_ipv6_port_mask;
	uint16_t src_ipv6_port_code;
	*/
};

struct tsdev_PC_ETH_CMD_REQ
{
	uint8_t FChn_Idx;
	uint8_t FCmd_Typ;//enum tsdev_eth_fcmd_type_t
	uint8_t rev[2 + 4];//var add 2024-8-16
	union _TPC_ETH_CMD_REQ_PAR
	{
		uint8_t rev[256 - 8]; //var add 2024-8-16
		//cmd 0: cfg eth chn
		struct _TPC_ETH_CMD_Cfg_Eth_Chn {
			// bit0-1 phy_type  : 0: 100base-Tx/1000Base-T, 1: 100/1000Base-T1, 2: 10base-T1S, 3: rev 
			// bit2 auto_neg 
			// bit3-4 speed : 0-10mbps, 1-100mbps, 2-1000mbps 
			// bit5 is_master
			// bit6-7 loopback   :0: no loop, 1: mac_loop, 2: phy-loop, 3: phy_remote loop
			uint8_t eth_config0;

			// bit0 wakeup       : 1;//0-disable, 1-enable
			// bit1-4 test_mode  : 3;//0x00 normal operation  other test mode
			// bit5-6 tx_mode    : 2;//
			// bit7 enable       : 1;//0x00 disable, 0x01 enable
			uint8_t eth_config1;

			// bit0-4 phy_addr   : 5;//not used
			// bit5 accept wrong crc frame
			// bit6-7: not used
			uint8_t eth_config2;

			// bit0: flow control    :1
			// bit1: Jumbo frame     :1
			// bit2: user FCS enable :1
			// bit3-4: enable bypass mode : 0: not enable, 1: mac bit bypass, 2: phy bypass.
			//note: only both port config under same mode could work
			//bit5: clean current filters
			uint8_t eth_config3;

			uint8_t rev[4]; //var add 2024-8-16

			union _TPC_ETH_CMD_Cfg_Eth_Chn_PAR
			{
				uint8_t rev[16];
				struct _TPC_ETH_CMD_Cfg_Eth_Chn_T1S {
					// bit0 plca enable: 0: disable(CSMA/CD mode), 1: enable 
					// bit1 termination res 100ohm: 0: do not install; 1: install
					// bit2 to_skip_en: 0: disable, 1: enable 
					uint8_t config;
					uint8_t rev;
					uint8_t to_timer; // 1~255: PLCA Transmit Opportunity time, bit times(100ns), default 32
					uint8_t node_id; // 0: PLCA Coordinator node, 1~254: PLCA Follower node, 255: PLCA Disabled
					uint8_t node_count; // 1~255: default 8
					uint8_t burst_count; // 0: Burst mode disabled. Only one frame will be transmitted per Transmit Opportunity.
					// 1~255: Number of additional frames that may be transmitted in a burst.
					uint8_t burst_timer; // 0~255: default 128
					uint8_t to_skip_num; // 0~255: default 0
					uint8_t plca_mult_id1; // 0 or 255: Value ignored
					// 1~254: Additional LocalID (transmit opportunity) assigned to node
					uint8_t plca_mult_id2; // Same as above
					uint8_t plca_mult_id3; // Same as above
					uint8_t plca_mult_id4; // Same as above
					uint8_t plca_mult_id5; // Same as above
					uint8_t plca_mult_id6; // Same as above
					uint8_t plca_mult_id7; // Same as above
					uint8_t plca_mult_id8; // Same as above
				}t1s;
			}pars;
		}Cfg_Eth_Chn;
		//cmd 1: clear wakeup reason
		struct _TPC_ETH_CMD_Clear_Wakeup {
			uint64_t rev;
		}Clr_Wakeup;
		//cmd 2:
		struct _TPC_ETH_CMD_Read_Chn_Status {
			uint64_t rev;
		} Read_Chn_Status;
		// cmd 3:
		struct _TPC_ETH_CMD_ptp_cal {
			uint8_t wirte_new_ptp_cfg;
			uint8_t rev[7];
			int64_t ptp_offset; //valid wirte_new_ptp_cfg != 0
			int64_t ptp_scale;//var add 2024-8-16
		} ptp_cal;
		// cmd 4:
		struct _TPC_ETH_CMD_add_filter {
			struct tsdev_eth_filter_def_t filter;
		} add_filter;
		// cmd 5:
		struct _TPC_ETH_CMD_read_filter_cnt {
			uint8_t rev;
		} read_filter_cnt;
		// cmd 6:
		struct _TPC_ETH_CMD_read_filter_by_idx {
			uint8_t rev;
		} read_filter_by_idx;
		// cmd 7:
		struct _TPC_ETH_CMD_clean_filter {
			uint8_t rev;
		} clean_filter;
		// cmd 8:
		struct _TPC_ETH_CMD_Stream_Gen_Ctrl {
			uint32_t frm_gap;//ns
			uint32_t frm_num;
			uint16_t inc_pos;//0-1522
			uint16_t inc_len;//
			uint8_t rev[3];
			//bit0: 0-stop, 1-start
			//bit1: 0-once, 1-loop
			uint8_t ctrl;
		} Stream_Gen_Ctrl;
		// cmd 9:
		struct _TPC_ETH_CMD_Stream_Pay_Cfg {
			uint16_t org_idx;//current pay segment start idx in the frm.
			uint16_t pay_len;//current pay segment len
			uint8_t pay[200];//current pay segment data
		} Stream_Pay_Cfg;
	}pars;
};


struct tsdev_HW_ETH_CMD_RSP
{
	uint8_t FChn_Idx;
	uint8_t FCmd_Typ;
	uint16_t FCmd_Cnt;
	uint32_t rev;//var add 2024-8-16
	uint64_t FTime_Us;
	union _TPC_ETH_CMD_RSP_PAR
	{
		uint8_t rev[64];
		//cmd 0: cfg eth chn
		struct _THW_ETH_CMD_RSP_Cfg_Eth_Chn {
			uint64_t rev;
		}Cfg_Eth_Chn;
		//cmd 2: 
		struct _THW_ETH_CMD_RSP_Read_Chn_Status {
			// bit0 link_ok : 1;
			// bit1 auto_neg_done : 1;
			// bit2 is_master : 1;
			// bit3 is_wakeup : 1;
			// bit4-5 phy_type: 2;
			// bit7 is_duplex : 1;
			uint8_t FStatus0;
			// bit0-1 speed  : 2;//0-10mbps, 1-100mbps, 2-1000mbps
			// bit2 mac ok?
			// bit3-5 phy test mode  :3
			// bit6-7 phypass: 2
			uint8_t FStatus1;

			uint8_t rev[6];
		} Read_Chn_Status;
		// cmd 3:
		struct _TPC_ETH_CMD_RESP_ptp_cal {
			uint64_t ptp_now;
			int64_t ptp_offset;
			int64_t ptp_scale;//var add 2024-8-16
		} ptp_cal;
		// cmd 4:
		struct _TPC_ETH_CMD_RESP_add_filter {
			uint8_t add_ok;
		} add_filter;
		// cmd 5:
		struct _TPC_ETH_CMD_RESP_read_filter_cnt {
			uint16_t cnt;
		} read_filter_cnt;
		// cmd 6:
		struct _TPC_ETH_CMD_RESP_read_filter_by_idx {
			struct tsdev_eth_filter_def_t filter;
		} read_filter_by_idx;
		// cmd 7:
		struct _TPC_ETH_CMD_RESP_clean_filter {
			uint8_t clean_ok;
		} clean_filter;
	}pars;
};


struct tsdev_ETH_Header
{
	uint8_t FIdxChn;//app channel index starting from 0 = Network index
	uint8_t rev1;//Network's switch index
	uint8_t rev2;   // Network's switch's port index, 0~127: measurement port,
	// 128~255: virtual port
	uint8_t FConfig;
	//  0-1: 0 = Rx, 1 = Tx, 2 = TxRq, 3 = tx_collision
	// 2: crc status, for tx, 0: crc is include in data, 1: crc is not include in data 
	//                for rx, 0: crc is ok, 1: crc is not ok 
	// 3: tx done type, 0: only report timestamp, 1: report full info(header+frame)
	uint16_t FEthernetPayloadLength;// Length of Ethernet payload data in bytes. Max. 1582 Byte(without Ethernet header), 1612 Byte(Inclusive ethernet header)
	uint16_t add_info;//bit 0-10:FTimeNs  //var add 2024-8-16
	uint64_t FTimeUs;//timestamp in us,avaliable on rx/txrq
	union _tsdev_ETH_Header_data {
		uint8_t* FEthernetDataAddr; // data ps32
		uint64_t FPadding;          // to be compatible with x64
		struct target_route_t {
			uint16_t router_dest;
			uint16_t router_dest_rev;
		}target_route; //bit0...15 router target, bit 16...31 is ~ val, only used between pc and hw
	} data_p;
	uint64_t PTP_FTime; // timestamp in PTP,avaliable on rx/txrq
};


#ifdef __cplusplus
extern "C"
{
#endif

typedef tsdev_err_t(*tsdev_api_eth_cmd_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
	uint16_t rev, uint16_t fsize, const struct tsdev_HW_ETH_CMD_RSP* data);
typedef tsdev_err_t(*tsdev_api_eth_frame_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
	uint16_t rev, uint16_t fsize, const struct tsdev_ETH_Header* data);

#ifdef __cplusplus
}
#endif

#endif