/**
 * Copyright (c) 2026:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_LIN_TYPES_H
#define __TSDEV_API_LIN_TYPES_H
#include "tsdev_api_base_types.h"

//--------------------------------------------------------------for LIN bus----------------------------------------------------

typedef enum
{
    LDF_DOWNLOAD_UDEF,
    LDF_DOWNLOAD_APPLY_NEW_LDF,
    LDF_DOWNLOAD_BAUDRATE,
    LDF_DOWNLOAD_FRAME,
    LDF_DOWNLOAD_EVENTANDSPORADIC_FRAME,
    LDF_DOWNLOAD_SCHEDULETABLE,
    LDF_DOWNLOAD_RUNTIME_SCHEDULETABLE,
    LDF_SWITCH_IDLE_SCHEDULETABLE,
    LDF_DOWNLOAD_SET_NORMAL_SCH_INDEX,
    LDF_SWITCH_RUNTIME_SCHEDULETABLE,
    LDF_DOWNLOAD_LIN_NODE_CONTROL,
    LDF_DOWNLOAD_SET_NODE_FUNCTION_TYPE, //11
    //LIN Tp Layer
    LIN_CMD_DIAG_TP_RESET,                               //12  Reset TP Layer
    LIN_CMD_DIAG_TP_MASTER_MASTER_REQUEST,               //13: As Master Node
    LIN_CMD_DIAG_TP_MASTER_MASTER_REQUEST_RESULT,        //14
    LIN_CMD_DIAG_TP_MASTER_MASTER_REQUEST_INTERVALTIME,  //15
    LIN_CMD_DIAG_TP_MASTER_SLAVE_RESPONSE,               //16
    LIN_CMD_DIAG_TP_MASTER_SLAVE_RESPONSE_RESULT,        //17
    LIN_CMD_DIAG_TP_MASTER_SLAVE_RESPONSE_INTERVALTIME,  //18
    LIN_CMD_DIAG_TP_SLAVE_TRANSMIT,                      //19: Work As Slave Node
    LIN_CMD_DIAG_TP_SLAVE_RECEIVE,  //20
    //LIN Diag Service Layer
    LIN_CMD_DIAG_SERVICE_MASTER_READ_DATA_BYID, //21 //Service Layer:0x22
    LIN_CMD_DIAG_SERVICE_MASTER_WRITE_DATA_BYID,//22 //ServiceID:0x2E
    LIN_CMD_DIAG_SERVICE_MASTER_SESSION_CONTROL,//23 //Session Control: 0x10
    LIN_CMD_DIAG_SERVICE_MASTER_FAUL_MEMORY_READ,//24 //Service ID:0x19
    LIN_CMD_DIAG_SERVICE_MASTER_FAUL_MEMORY_CLEAR,//25 //ServiceID:0x14
    LIN_CMD_DIAG_TP_PARAMETER_DEFAULT, //Set default parameter of TP Layer
    LIN_CMD_DIAG_TP_PARAMETER_SPEC,   //Set special parameter of TP Layer
    LIN_ACTIVE_DEACTIVE_FRAME_IN_SCHEDULE_TABLE,
    LIN_MAINTAIN_OUTPUT_LEVEL_IN_IDLE_MODE
}TLDF_CONFIG_CMD;
typedef enum {
    LIN_FRM_UNCD = 0X00
    , LIN_FRM_EVNT = 0x01
    , LIN_FRM_SPRDC = 0x10
    , LIN_FRM_DIAG = 0x11
    , LIN_FRM_WAKEUP = 0x12
}ts_lin_frame_type;
typedef enum {
    LIN_RES_NOTHING = 0x00,                 /**< This frame does not require to response.*/
    LIN_RES_PUB = 0x01,                     /**< Publisher response.*/
    LIN_RES_SUB = 0x10                      /**< Subscriber response.*/
} ts_lin_frame_response;
typedef enum {
    LIN_PROTOCOL_13,
    LIN_PROTOCOL_20,    /**< LIN protocol version 2.0 */
    LIN_PROTOCOL_21,    /**< LIN protocol version 2.1 */
    LIN_PROTOCOL_J2602  /**< J2602 protocol  */
} ts_lin_protocol_handle;
typedef enum {
    LIN_MASTER_,     /**< master node */
    LIN_SLAVE_,       /**< slave node */
    LIN_MONITOR_      /**< Monitor node */
} ts_lin_function;
typedef enum
{
    tsdev_LD_CMD_SUCCESS,
    tsdev_IDX_ERR_LIN_FRAME_CNT_OVERRUN,
    tsdev_IDX_ERR_LIN_SCH_CNT_OVERRUN,
	tsdev_IDX_ERR_LIN_MASTER_TRANSMIT_N_AS_TIMEOUT = 202,
    tsdev_IDX_ERR_LIN_MASTER_TRANSMIT_TRANSMIT_ERROR = 203,
    tsdev_IDX_ERR_LIN_MASTER_REV_N_CR_TIMEOUT = 204,
    tsdev_IDX_ERR_LIN_MASTER_REV_ERROR = 205,
    tsdev_IDX_ERR_LIN_MASTER_REV_INTERLLEAVE_TIMEOUT = 206,
    tsdev_IDX_ERR_LIN_MASTER_REV_NO_RESPONSE = 207,
    tsdev_IDX_ERR_LIN_MASTER_REV_SN_ERROR = 208,
    tsdev_IDX_ERR_LIN_SLAVE_TRANSMIT_N_CR_TIMEOUT = 209,
    tsdev_IDX_ERR_LIN_SLAVE_REV_N_CR_TIMEOUT = 210,
    tsdev_IDX_ERR_LIN_SLAVE_TRANSMIT_ERROR = 211,
    tsdev_IDX_ERR_LIN_SLAVE_REV_ERROR = 212
}TLD_CMD_RESULT;
typedef enum {
	LIN_LLD_PID_OK,                     /**< LIN_LLD_PID_OK */
	LIN_LLD_TX_COMPLETED,               /**< LIN_LLD_TX_COMPLETED */
	LIN_LLD_RX_COMPLETED,               /**< LIN_LLD_RX_COMPLETED */
	LIN_LLD_PID_ERR,                    /**< LIN_LLD_PID_ERR */
	LIN_LLD_FRAME_ERR,                 /**< LIN_LLD_FRAME_ERR */
	LIN_LLD_CHECKSUM_ERR,               /**< LIN_LLD_CHECKSUM_ERR */
	LIN_LLD_READBACK_ERR,               /**< LIN_LLD_READBACK_ERR */
	LIN_LLD_ENOUGHT_DATA_TIMEOUT,       /**< Nodata timeout */
	LIN_LLD_BUS_ACTIVITY_TIMEOUT,       /**< LIN_LLD_BUS_ACTIVITY_TIMEOUT */
	LIN_LLD_SEND_BREAK_TIMEOUT,
	LIN_LLD_RECEIVE_NODATA_TIMEOUT,
	LIN_LLD_INTERVAL_TIME_TOO_SHORT
} lin_lld_event_id;
struct tsdev_lin_config_t  
{
    uint8_t  FCommand;
    uint8_t  FLINHandle;
    uint8_t  FIsVNM;
    uint8_t  FRealItemNum;
    uint8_t  rev[4];
    union tsdev_lin_config_par_t
    {
        uint8_t  FData[1000];
        //cmd0-LDF_DOWNLOAD_UDEF-no par
        //cmd1-LDF_DOWNLOAD_APPLY_NEW_LDF-no par
        //cmd2-LDF_DOWNLOAD_BAUDRATE
        struct tsdev_lin_config_par_cmd2_t
        {
            uint32_t baudrate; //freq in Hz
            //bit0-3: version Current is lin_protocol_handle, reserved: 4-15
            //bit4: onlyMonitorPIDInLDF
            //bit7: isLowLevelIdleMode
            uint8_t config;
        }cmd2;
        //cmd3-LDF_DOWNLOAD_FRAME
        struct tsdev_lin_config_par_cmd3_t
        {
            struct tsdev_lin_config_par_lin_frame_t
            {
                uint8_t  FType;                //ts_lin_frame_type
                uint8_t  FID;                  //You can fill in the Frame ID or PID here
                //The response status of the PID corresponding to lin_frame_desponse: 
                //      receiving data, sending data, or not related to oneself
                uint8_t  FResponse;   //ts_lin_frame_response     
                uint8_t  FDLC;                           //Frame len
                uint8_t  FrameIntialData[8];             //Initialize data
                uint8_t  updatedFlagSize;                //It's related to the number of signals , not used
                uint8_t  rev[3];
            }frame_def[62]; //!!!!!!!!!!!!!warrning: pack is need here!!!!!!!!!!!!!
        }cmd3;
        //cmd4-LDF_DOWNLOAD_EVENTANDSPORADIC_FRAME-no par
        //cmd5-LDF_DOWNLOAD_SCHEDULETABLE
        //cmd6-LDF_DOWNLOAD_RUNTIME_SCHEDULETABLE
        struct tsdev_lin_config_par_cmd5_t
        {
            uint8_t num_slots;
            uint8_t sch_tbl_type;
            uint8_t rev[6];
            struct tsdev_lin_config_par_cmd5_sch2frame_t {
                uint8_t      frm_id;             /**< Frame ID, in case of unconditional or event triggered frame. For sporadic frame the value will be 0 (zero). */
                uint8_t      delay_spec;      /**< Actual slot time in INTEGER for one frame.*/
                uint8_t      tl_queue_data[8];      /**< Data used in case of diagnostic or configuration frame*/
                uint8_t      rev[6];
            }sch_data[62];//!!!!!!!!!!!!!warrning: pack is need here!!!!!!!!!!!!!
        }cmd5_cmd6;
        //cmd7-LDF_SWITCH_IDLE_SCHEDULETABLE-no par
        //cmd8-LDF_DOWNLOAD_SET_NORMAL_SCH_INDEX
        struct tsdev_lin_config_par_cmd8_t
        {
            uint8_t sch_idx;
        }cmd8;
        //cmd9-LDF_SWITCH_RUNTIME_SCHEDULETABLE-no par
        //cmd10-LDF_DOWNLOAD_LIN_NODE_CONTROL-not support
        struct tsdev_lin_config_par_cmd10_t
        {
            uint8_t FIsDisable;
        }cmd10;
        //cmd11-LDF_DOWNLOAD_SET_NODE_FUNCTION_TYPE-not support
        struct tsdev_lin_config_par_cmd11_t
        {
            uint8_t type;//ref ts_lin_function
        }cmd11;
        //cmd12-LIN_CMD_DIAG_TP_RESET-no par
        //cmd13-LIN_CMD_DIAG_TP_MASTER_MASTER_REQUEST
        struct tsdev_lin_config_par_cmd13_t
        {
            uint8_t packagNum_sub_1;
            uint8_t packageIdx;
            uint8_t ANAD;
            uint8_t packageLen_lsb;
            uint8_t packageLen_msb;
            uint8_t data[1000 - 5];
        }cmd13;
        //cmd14-LIN_CMD_DIAG_TP_MASTER_MASTER_REQUEST_RESULT-not here
        //cmd15-LIN_CMD_DIAG_TP_MASTER_MASTER_REQUEST_INTERVALTIME
        //cmd16-LIN_CMD_DIAG_TP_MASTER_SLAVE_RESPONSE-no par
        //cmd17-LIN_CMD_DIAG_TP_MASTER_SLAVE_RESPONSE_RESULT-not here
        //cmd18-LIN_CMD_DIAG_TP_MASTER_SLAVE_RESPONSE_INTERVALTIME
        struct tsdev_lin_config_par_cmd15_18_t
        {
            uint8_t delay_ms_msb;
            uint8_t delay_ms_lsb;
        }cmd15_18;
        //cmd19  LIN_CMD_DIAG_TP_SLAVE_TRANSMIT-not here
        // cmd20 LIN_CMD_DIAG_TP_SLAVE_RECEIVE,-not here
        //cmd21-LIN_CMD_DIAG_SERVICE_MASTER_READ_DATA_BYID
        struct tsdev_lin_config_par_cmd21_t
        {
            uint8_t NAD;
            uint8_t rev[2];
            uint8_t did_msb;
            uint8_t did_lsb;
        }cmd21;
        //cmd22-LIN_CMD_DIAG_SERVICE_MASTER_WRITE_DATA_BYID
        struct tsdev_lin_config_par_cmd22_t
        {
            uint8_t NAD;
            uint8_t len_lsb;
            uint8_t len_msb;
            uint8_t did_msb;
            uint8_t did_lsb;
            uint8_t data[1000 - 3-2];
        }cmd22;
        //cmd23-LIN_CMD_DIAG_SERVICE_MASTER_SESSION_CONTROL
        struct tsdev_lin_config_par_cmd23_t
        {
            uint8_t NAD;
            uint8_t len_lsb;
            uint8_t len_msb;
            uint8_t sub_fun;
            uint8_t data[1000 - 4];
        }cmd23;
        //cmd24-LIN_CMD_DIAG_SERVICE_MASTER_FAUL_MEMORY_READ-no par
        //cmd25-LIN_CMD_DIAG_SERVICE_MASTER_FAUL_MEMORY_CLEAR-no par
        //cmd26-LIN_CMD_DIAG_TP_PARAMETER_DEFAULT
        //cmd27-LIN_CMD_DIAG_TP_PARAMETER_SPEC
        struct tsdev_lin_config_par_cmd26_27_t
        {
            uint8_t DiagReqIntervalTime_msb;
            uint8_t DiagReqIntervalTime_lsb;

            uint8_t DiagResIntervalTime_msb;
            uint8_t DiagResIntervalTime_lsb;

            uint8_t DiagResRetryCounter_msb;
            uint8_t DiagResRetryCounter_lsb;
        }cmd26_27;
        //cmd28-LIN_ACTIVE_DEACTIVE_FRAME_IN_SCHEDULE_TABLE
        struct tsdev_lin_config_par_cmd28_t
        {
            uint8_t sch_idx;
            uint8_t AID;

            uint8_t AItemIndex_msb;
            uint8_t AItemIndex_lsb;

            uint8_t AIsActive;
        }cmd28;
        //cmd29-LIN_MAINTAIN_OUTPUT_LEVEL_IN_IDLE_MODE-not support
    }par;
};

struct tsdev_lin_config_resp_t
{
    uint16_t FCommand; //
    uint8_t FStatus;   // u16->u8  TLD_CMD_RESULT
    uint8_t FDir;      // Send or Receive
    uint16_t FDataLength;
    uint8_t FIdxChn;
    uint8_t FReserved;   // Added 1001
    uint64_t FTimeStamp; // Added 1001
    union tsdev_lin_config_resp_par_t
    {
        struct tsdev_lin_config_resp_par_cmd17_20_t
        {
            uint8_t packageNum;
            uint8_t packageIdx;
            uint8_t packageLen_msb;
            uint8_t packageLen_lsb;
            uint8_t array[120 - 4];
        } cmd17_20; // Translate layer max support 128 bytes onece----todo-------
        // LIN_CMD_DIAG_TP_MASTER_MASTER_REQUEST_RESULT no-par
        // LIN_CMD_DIAG_TP_MASTER_SLAVE_RESPONSE_RESULT uint8_t []  resp
        // LIN_CMD_DIAG_TP_SLAVE_TRANSMIT no-par
        // LIN_CMD_DIAG_TP_SLAVE_RECEIVE uint8_t []  resp
    } pars;
};

struct tsdev_lin_t
{
    uint8_t FIdxChn;  // channel index starting from 0
    uint8_t FErrCode; // 0: normal
    /**
     * [7] tbd
     * [6] 0-not logged, 1-already logged
     * [5-4] FHWType
     * [3] 0-not ReceivedSync, 1- ReceivedSync
     * [2] 0-not received FReceiveBreak, 1-Received Break
     * [1] 0-not send FReceiveBreak, 1-send Break
     * [0] dir: 0-RX, 1-TX
     */
    uint8_t FProperties; // default 0, masked status:
    uint8_t FDLC;        // dlc from 0 to 8
    uint8_t FIdentifier; // LIN identifier:0--64
    uint8_t FChecksum;   // LIN checksum
    uint8_t FStatus;     // place holder 1
	uint8_t rev;
    int64_t FTimeUS;     // timestamp in us
    uint8_t FData[8];
};

struct tsdev_LIN_frame {
    uint8_t  FIdxChn;             // channel index starting from 0
    uint8_t  FCommandType;        // FCommandType:0:LIN Message 1: GotoSleep 2: Wakeup Other: Undef
    uint8_t  FIdentifier;         // LIN identifier:0--64
    uint8_t  FCtrlGrp;            // default 0, masked status:
    // [7] tbd
    // [6] 0-not logged, 1-already logged
    // [5-4] FHWType //DEV_MASTER,DEV_SLAVE,DEV_LISTENER
    // [3] 0-not ReceivedSync, 1- ReceivedSync
    // [2] 0-not received FReceiveBreak, 1-Received Break
    // [1] 0-not send FReceiveBreak, 1-send Break
    // [0] dir: 0-RX, 1-TX
    uint8_t  FDLC;                // dlc from 0 to 8
    uint8_t  rev[3];
    union tsdev_LIN_frame_par_t {
        uint8_t  FData[8];            //FCommandType == 0 8 data bytes to send
        struct tsdev_LIN_frame_par_wakeup_t {
            uint8_t bit_len;//Wakeup low level bit length >= 3
            uint8_t delay_ms;//Wakeup delay timeMs
            uint8_t t_times; //Wakeup trigger transmit times
        }wakeup;
    }pars;
};

struct tsdev_LIN_frame_rx {
    uint64_t FTimestamp;          // hw local timestamp when this command is issued
    // >>>>>> protocol end <<<<<<
    uint8_t  FIdxChn;             // channel index starting from 0
    uint8_t  FHWType;             // DEV_MASTER, DEV_SLAVE, DEV_LISTENER
    uint8_t  FStatus;             // FrameStatus
    uint8_t  FDir;                // Data Dir 0-RX, 1-TX
    uint8_t  FIdentifier;         // LIN identifier:0--64
    uint8_t  FProperty;   
//#define   MASK_LINProp_DIR_TX          0x01
//#define   MASK_LINProp_SEND_BREAK      0x02
//#define   MASK_LINProp_RECEIVED_BREAK  0x04
//#define   MASK_LINProp_RECEIVED_SYNC   0x08
//#define   LINProp_HW_TYPE_POS         (0x04)
//#define   MASK_LINProp_HW_TYPE         0x30
//#define   MASK_LINProp_LOGGED          0x40
//#define   MASK_LINProp_SEND_SYNC       0x80 
    uint8_t  FReserved0;                 
    uint8_t  FReserved1;                   
    uint8_t  FReserved2;                 
    uint8_t  FDLC;                // dlc from 0 to 8
    uint8_t  FCheckSum;           // checksum
    uint8_t  FErrorCode;          // lin_lld_event_id
    uint8_t  FData[8];            // 8 data bytes to send
};


typedef tsdev_err_t(*tsdev_lin_cmd_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
	uint16_t rev, uint16_t fsize, const struct tsdev_lin_config_resp_t* data);
typedef tsdev_err_t(*tsdev_lin_frame_event_t)(tsdev_handle_t handle, void* usr_arg, tsdev_tsmsg_t msg,
	uint16_t rev, uint16_t fsize, const struct tsdev_LIN_frame_rx* data);

#endif