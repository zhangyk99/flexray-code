/**
 * Copyright (c) 2026:Shanghai TOSUN Technology Ltd.
 *
 * The software mentioned in this copyright statement includes the automatic
 * code generator function module of TSMaster software and the embedded code it
 * generates. Among them, the copyright of the automatic code generation
 * function module of TSMaster software is owned by Shanghai TOSUN Technology
 * Ltd..It is protected by the Copyright Law of the People's Republic of China,
 * the Regulations on the Protection of Computer Software, the Intellectual
 * Property Protection Law, the Patent Law of the People's Republic of China and
 * relevant international copyright treaties, laws, regulations, and other
 * intellectual property laws and treaties.
 *
 * The embedded code generated by the automatic code generation function of the
 * TSMaster is a non-commercial code whose copyright belongs to Shanghai TOSUN
 * Technology Ltd. or the original copyright owner of the embedded code, and is
 * only for personal learning and use. Shanghai TOSUN Technology Ltd. does not
 * provide any kind of warranty, whether express or implied. All risks are borne
 * by the user, and Shanghai TOSUN Technology Ltd. does not assume any joint
 * responsibility.
 *
 * The semiconductor manufacturer's LOGO and product model displayed in the
 * TSMaster are only for the convenience of user selection and useage,its
 * copyright and ownership remain with the respective copyright owners,Shanghai
 * TOSUN Technology Ltd. does not provide any guarantee and rights guarantee for
 * this, and does not assume joint and several liability for any possible
 * infringement.
 *
 * Shanghai TOSUN Technology Ltd. reserves the right to modify and upgrade the
 * software mentioned in this copyright statement without notifying users, and
 * reserves the right to modify this license agreement.
 */
#ifndef __TSDEV_API_IO_TYPES_H
#define __TSDEV_API_IO_TYPES_H
#include "tsdev_api_base_types.h"

enum tsdev_dev_io_cmd_enum
{
    tsdev_dev_dido_set_glb_par = 0,
    tsdev_dev_dido_set_bridge = 1,
    tsdev_dev_dido_mode = 2,
    tsdev_dev_aiao_mode = 3,
    tsdev_dev_dido_read = 4,
    tsdev_dev_dido_write = 5,
    tsdev_dev_pwm_read = 6,
    tsdev_dev_pwm_write = 7,
    tsdev_dev_aiao_read = 8,
    tsdev_dev_aiao_write = 9
};

enum tsdev_dev_io_daq_enum
{
    tsdev_dev_dido_io_report = 0,
    tsdev_dev_dido_pwm_report = 1,
    tsdev_dev_aiao_report = 2
};
union tsdev_dev_io_cmd_resp
{
    uint8_t rev[8];
    struct tsdev_dev_dido_cmd0_resp0
    {
        // bit 0 - 6: tsdev_dev_dido_set_glb_par
        // bit 7: op_valid_ok (cmd: cmd valid;  resp: op ok)
        uint8_t cmd;
        uint8_t is_12v;
        uint16_t report_cycle_ms; // tsdev_dev_dido_io_report report cycle
    } cmd0_resp0;
    struct tsdev_dev_dido_cmd1_resp1
    {
        // bit 0 - 6: tsdev_dev_dido_set_bridge
        // bit 7: op_valid_ok (cmd: cmd valid;  resp: op ok)
        uint8_t cmd;
        uint8_t dido_1_2; // dido1 bridge dido2,0: reset; 1: set; 2: not change,
        uint8_t dido_3_4; // dido3 bridge dido4,0: reset; 1: set; 2: not change,
    } cmd1_resp1;
    struct tsdev_dev_dido_cmd2_resp2
    {
        // bit 0 - 6: tsdev_dev_dido_mode
        // bit 7: op_valid_ok (cmd: cmd valid;  resp: op ok)
        uint8_t cmd;
        uint8_t dido_idx;
        uint16_t dido_input_thread;   // 0-5000, unit is 1mV
        uint8_t dido_mode0;           // bit0: io type: 0: io; 1: pwm
        uint8_t dido_mode1;           // bit0-1: 0: input; 1: push-pull; 2: pull(p-mos) only; 3: push(n-mos) only /// ? out high/low level
        uint16_t pwm_report_cycle_ms; // tsdev_dev_dido_pwm_report report cycle
    } cmd2_resp2;
    struct tsdev_dev_aiao_cmd3_resp3
    {
        // bit 0 - 6: tsdev_dev_aiao_mode
        // bit 7: op_valid_ok (cmd: cmd valid;  resp: op ok)
        uint8_t cmd;
        uint8_t aiao_idx;
        uint8_t aiao_mode; // 0: input, 1: output
        uint8_t rev;
        uint16_t report_cycle_ms;
    } cmd3_resp3;

    struct tsdev_dev_dido_cmd4_resp4
    {
        // bit 0 - 6: tsdev_dev_dido_read/tsdev_dev_dido_write
        // bit 7: op_valid_ok (cmd: cmd valid;  resp: op ok)
        uint8_t cmd;
        uint8_t dido_idx;
        uint8_t io_status;
        uint8_t rev;
    } cmd4_resp4;
    struct tsdev_dev_dido_cmd5_resp5
    {
        // bit 0 - 6: tsdev_dev_pwm_read/tsdev_dev_pwm_write
        // bit 7: op_valid_ok (cmd: cmd valid;  resp: op ok)
        uint8_t cmd;
        uint8_t pwm_idx;
        uint16_t duty; // uint is 0.01%
        uint32_t freq; // unit is hz
    } cmd5_resp5;
    struct tsdev_dev_aiao_cmd6_resp6
    {
        // bit 0 - 6: tsdev_dev_aiao_read/tsdev_dev_aiao_write
        // bit 7: op_valid_ok (cmd: cmd valid;  resp: op ok)
        uint8_t cmd;
        uint8_t aiao_idx;
        uint16_t voltage; // uint is 1mV
    } cmd6_resp6;
};

// max 120 channels
union tsdev_dev_io_daq_resp
{
    uint8_t rev[1024];
    struct tsdev_dev_dido_resp10
    {
        uint64_t timestamp;
        uint8_t cmd;           // tsdev_dev_io_daq_enum
        uint8_t cnt;           // rolling cnt
        uint8_t io_status[15]; // one bit per channel
    } resp10;
    struct tsdev_dev_dido_resp11
    {
        uint64_t timestamp;
        uint8_t cmd; // tsdev_dev_io_daq_enum
        uint8_t cnt;
        uint8_t pwm_data_cnt;
        uint8_t rev[5];
        struct tsdev_dev_dido_pwm_data_t
        {
            uint8_t ch_idx;
            uint8_t rev;
            uint16_t duty; // uint is 0.01%
            uint32_t freq; // unit is 0.01Hz
        } data[120];
    } resp11;
    struct tsdev_dev_aiao_resp12
    {
        uint64_t timestamp;
        uint8_t cmd; // tsdev_dev_io_daq_enum
        uint8_t cnt;
        uint8_t aiao_data_cnt;
        uint8_t rev[5];
        struct tsdev_dev_aiao_data_t
        {
            uint8_t ch_idx;
            uint8_t rev;
            uint16_t voltage; // in 1mV
        } data[120];
    } resp12;
};

// when tsdev_api_io_cmd_burst_async is called, resp is an array which has elements of cmd_cnt.
typedef tsdev_err_t (*tsdev_io_cmd_event_t)(tsdev_handle_t handle, void *usr_arg, tsdev_tsmsg_t msg,
                                            uint16_t rev, uint16_t fsize, const union tsdev_dev_io_cmd_resp *resp);
typedef tsdev_err_t (*tsdev_io_daq_event_t)(tsdev_handle_t handle, void *usr_arg, tsdev_tsmsg_t msg,
                                            uint16_t rev, uint16_t fsize, const union tsdev_dev_io_daq_resp *daq);

#endif
